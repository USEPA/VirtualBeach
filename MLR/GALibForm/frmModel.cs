using System;
using System.Collections.Generic;
using System.Globalization;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.IO;
using System.Windows.Forms;
using System.Threading;
using System.Linq;
using System.Collections;
using System.Xml;
using System.Runtime.Serialization;
using System.Collections.ObjectModel;

using ZedGraph;
using GALib;
//using VBStatistics;
using VBCommon.Statistics;
using MultipleLinearRegression;
using Combinatorics;
using WeifenLuo.WinFormsUI.Docking;
using MLRCore;
//using LogUtilities;
using CrossValidation;
using VBControls;
using VBCommon;
using VBCommon.Controls;
using VBCommon.Transforms;

namespace GALibForm
{
    public partial class frmModel : UserControl
    {
        private Dictionary<string, object> dictPackedState;
        public List<string> _lstSelectedVariables = null;

        //public event EventHandler ClearList;
        //public event MyEventHandler AddToList;
        //public delegate void MyEventHandler(MyEventArg args);

        public System.Windows.Forms.Label lblAvailVars = null;
        public System.Windows.Forms.Label lblDepVars = null;

        public delegate void ModelChangedEventHandler();
        public ModelChangedEventHandler ModelChanged;
        public event EventHandler ModelSelected;

        private volatile bool _cancelRun = false;
        private bool boolModelingComplete = false;

        private IPointListEdit _listFitnessProgress = null;

        //This is the full data table from the datasheet
        private DataTable _dtFull = null;        

        //The list of MLRIndividuals generated by various search techniques (e.g. GA, exhaustive, ...)
        private List<IIndividual> _list = null;

        //list of residual rebuilds
        private List<VBCommon.Statistics.MultipleRegression> _listRebuilds = null;
        private int _selectedRebuildIndex = -1;

        private MLRDataManager _dataMgr = null;
        private MLRModelingInfo _modelingInfo = null;

        private GALib.GAManager _gaManager = null;
        private ExhaustiveSearchManager _esManager = null;
        private Thread _runThread = null;

        private int _numVars;        //Number of independent variables in the dataset
        int _numObs;        //Number of observations in the dataset
        int _maxIndVars;        //Maximum number of variables (including interaction terms) allowed in model
        int _totVar;        //Total number of variables (including interaction terms) available to model
        int _userSpecifiedNumVars;
        int _maxVIF;        //Maximum VIF allowed for model to be valid        
        int _seed;        //Seed for random number generator

        //Threshold value used for sensitiviy, specificity, accuracy
        double _decisionThreshold;
        double _mandateThreshold;
        DependentVariableTransforms xfrmThreshold = DependentVariableTransforms.none;
        double dblThresholdPowerTransformExponent = 1;

        public static bool ThresholdChecked;        //For reporting/plotting of optional eval criteria
        
        private int[] _ndxs;        //for ROC curve plotting
        private List<double[]> _XYPlotdata;
        private int _selectedModelIndex = -1;

        Dictionary<string, List<object>> _tableVals = null; 

        private enum _mlrState { clean, dirty };
        private _mlrState _state = _mlrState.clean;

        private int _smi = -1;
        private int _pmi = -1;

        private DependentVariableTransforms _depVarTransform = DependentVariableTransforms.none;
        private double _depVarPowerTransformExponent = 1.0;

        #region residuals globals

        private const double cutoff = 0.65d;
        private const double cookscutoff = 0.05d;

        private double[] _dffits = null;
        private double[] _cooks = null;
        private double _dffitsThreshold = cutoff;
        private double _cooksThreshold = cookscutoff;

        private double[] _predictions = null;
        private double[] _standardResiduals = null;
        private double[] _observations = null;

        private VBCommon.Statistics.MultipleRegression _model = null;

        private int _dffitsRecno2Remove;
        private int _cooksRecno2Remove;

        private string _dffitsDateTime2Remove;
        private string _cooksDataTime2Remove;

        private double _dffitsResidValue2Remove;
        private double _cooksResidValue2Remove;

        private List<int> _recsRemoved = null;
        private List<double> _residValueRemoved = null;
        private List<string> _residTypeRemoved = null;

        private DataSet _modelBuildTables = null;
        private string _currentModelTableName = string.Empty;

        private bool _gobtnState = true;

        //private Dictionary<string, double> _selectedModel = null;
        private int _maxIterations = 0;

        private Dictionary<int, string> _residualInfo = null;

        private int _selectedRebuild = -1;

        private bool _continue = true;
        #endregion

        public DependentVariableTransforms DepVarTrans
        {
            set { _depVarTransform = value; }
            get { return _depVarTransform; }
        }


        public double DepVarTransExp
        {            
            get { return _depVarPowerTransformExponent; }
            set
            { _depVarPowerTransformExponent = value; }
        }


        public double DecisionThreshold
        {
            get { return _decisionThreshold; }
            set
            {
                _decisionThreshold = value;
                tbDecThreshHoriz.Text = value.ToString();
            }
        }


        public double RegulatoryThreshold
        {
            get { return _mandateThreshold; }
            set
            {
                _mandateThreshold = value;
                tbRegThreshVert.Text = value.ToString();
            }
        }


        public DependentVariableTransforms ThresholdTransform
        {
            get { return xfrmThreshold; }
            set
            {
                xfrmThreshold = value;
                switch (value)
                {
                    case DependentVariableTransforms.none:
                        rbValMET.Checked = true;
                        break;
                    case DependentVariableTransforms.Log10:
                        rbLog10ValMET.Checked = true;
                        break;
                    case DependentVariableTransforms.Ln:
                        rbLogeValMET.Checked = true;
                        break;
                    case DependentVariableTransforms.Power:
                        rbPwrValMET.Checked = true;
                        break;
                }
            }
        }


        public double ThresholdTransformExponent
        {
            get { return dblThresholdPowerTransformExponent; }
            set
            {
                dblThresholdPowerTransformExponent = value;
                txtPwrValMET.Text = value.ToString();
            }
        }

        
        public Dictionary<string, object> PackedState
        {
            get { return dictPackedState; }
        }


        public MLRModelingInfo ModelInfo { get { return _modelingInfo; } }


        public frmModel()
        {
            InitializeComponent();
            mlrPlots1.CallForProbs += new EventHandler(UpdateExceedanceProbs);
            mlrPlots2.CallForProbs += new EventHandler(UpdateExceedanceProbs);
            _dataMgr = MLRDataManager.GetDataManager();
            cbCriteria.SelectedIndex = 0;
        }


        public bool ModelingComplete
        {
            get { return boolModelingComplete; }
        }


        private void ConvertThresholdsToModeledUnits()
        {
            //Remove the threshold transform
            _decisionThreshold = Apply.UntransformThreshold(_decisionThreshold, ThresholdTransform, ThresholdTransformExponent);
            _mandateThreshold = Apply.UntransformThreshold(_mandateThreshold, ThresholdTransform, ThresholdTransformExponent);

            //Apply the input transform
            _decisionThreshold = Apply.TransformThreshold(_decisionThreshold, DepVarTrans, DepVarTransExp);
            _mandateThreshold = Apply.TransformThreshold(_mandateThreshold, DepVarTrans, DepVarTransExp);
        }


        public void InitControls()
        {
            if (_list != null)
            {
                _list.Clear();
                _list = null;
            }
            boolModelingComplete = false;
            listBox1.Items.Clear();
            listView1.Items.Clear();
            listView2.Items.Clear();
            listView3.Items.Clear();
            listView4.Items.Clear();
            InitProgressGraph();
            InitResultsGraph();
            zgcROC.GraphPane.CurveList.Clear();
            zgcROC.Refresh();

            //huh? init this bad boy somehow...
            mlrPlots1.ZGC.GraphPane.CurveList.Clear();
            mlrPlots1.LISTVIEW.Items.Clear();        
        }


        //Pack State for Serializing
        public IDictionary<string, object> PackProjectState()
        {
            if (PackedState != null)
            {
                //Pack the variable selection control and prediction-v-observation charts:
                if (PackedState.ContainsKey("VariableSelection")) { PackedState.Remove("VariableSelection"); }
                if (PackedState.ContainsKey("PredPlot1")) { PackedState.Remove("PredPlot1"); }
                if (PackedState.ContainsKey("PredPlot2")) { PackedState.Remove("PredPlot2"); }

                PackedState.Add("VariableSelection", PackVariableSelectionState());
                PackedState.Add("PredPlot1", mlrPlots1.PackState());
                PackedState.Add("PredPlot2", mlrPlots2.PackState());
            }

            return PackedState;
        }


        /// <summary>
        /// Fires when the app saves a project file
        /// </summary>
        /// <param name="projMgr"></param>
        private Dictionary<string, object> ProjectSave()
        {
            //Not really much to save if no models were generated
            if ((_list == null) || (_list.Count < 1))
                return null;

            //Probably dont need this check.  _list and listBox1 should be sync'ed up
            if (listBox1.Items.Count < 1)
                return null;

            //User has not selected a model
            if (_selectedModelIndex < 0)
                return null;

            Dictionary<string, object> mlrPackState = new Dictionary<string, object>();            
            MLRIndividual mlrIndiv = _list[_selectedModelIndex] as MLRIndividual;

            if (mlrIndiv == null)
                return null;

            //Add the variable-coefficient model
            mlrPackState.Add("MLRModel", new Dictionary<string, double>(mlrIndiv.Model));               
            _modelingInfo = new MLRModelingInfo();
            _modelingInfo.DependentVariable = _dataMgr.ModelDependentVariable;
            _modelingInfo.ThresholdTransform = xfrmThreshold;
            _modelingInfo.ThresholdPowerTransformExponent = dblThresholdPowerTransformExponent;

            //Save dependent variable transform
            _modelingInfo.Model = new Dictionary<string,double>();
            _modelingInfo.IndependentVariables = new List<ListItem>();
            foreach (KeyValuePair<string, double> pair in mlrIndiv.Model)
            {
                _modelingInfo.IndependentVariables.Add(new ListItem(pair.Key, pair.Key));
                _modelingInfo.Model.Add(pair.Key, pair.Value);
            }

            //this nonsense is for passing rebuilds to prediction (rebuilds are MultipleRegression objects, bestfits are MLRIndividual objects) 
            if (_listRebuilds != null)
            {
                if (_selectedRebuildIndex > 0)
                {
                    _modelingInfo = new MLRModelingInfo();
                    _modelingInfo.Model = new Dictionary<string, double>();
                    _modelingInfo.IndependentVariables = new List<ListItem>();
                    _modelingInfo.SelectedRebuild = new Dictionary<string, double>();

                    foreach (KeyValuePair<string, double> pair in _listRebuilds[_selectedRebuildIndex].Model)
                    {
                        _modelingInfo.IndependentVariables.Add(new ListItem(pair.Key, pair.Key));
                        _modelingInfo.Model.Add(pair.Key, pair.Value);
                        _modelingInfo.SelectedRebuild.Add(pair.Key, pair.Value);
                    }

                    _modelingInfo.SelectedModel = _selectedModelIndex;
                    _modelingInfo.SelectedRebuildIndex = _selectedRebuildIndex;
                }

                List<Dictionary<string, object>> listPackedRebuilds = new List<Dictionary<string, object>>();
                foreach (MultipleRegression mlrModel in _listRebuilds)
                {
                    listPackedRebuilds.Add(mlrModel.PackState());
                }
                mlrPackState.Add("RebuildList", listPackedRebuilds);
                mlrPackState.Add("RebuildResidualDict", _residualInfo);
            }

            mlrPackState.Add("IndependentVariables", _lstSelectedVariables);
            
            //Save the chromosomes
            List<List<string>> chromosomes = new List<List<string>>();
            for (int i = 0; i < _list.Count; i++)
            {
                //List<short> lst = new List<short>(_list[i].Chromosome);
                List<string> lst = new List<string>(_list[i].Chromosome);
                chromosomes.Add(lst);
            }

            mlrPackState.Add("MLRIndividualChromosomes", chromosomes);

            MLRIndividual indiv = _list[_selectedModelIndex] as MLRIndividual;
            _modelingInfo.DecisionThreshold = indiv.DecisionThreshold;
            _modelingInfo.MandatedThreshold = indiv.MandatedThreshold;
            _modelingInfo.FitnessCriteria = (int)indiv.FitnessCriteria;
            _modelingInfo.MaxGeneValue = indiv.MaxGeneValue;
            _modelingInfo.MaxVIF = indiv.MaxVIF;
            _modelingInfo.NumGenes = indiv.NumGenes;
            _modelingInfo.Accuracy = indiv.Accuracy;
            _modelingInfo.AdjustedR2 = indiv.AdjustedR2;
            _modelingInfo.AIC = indiv.AIC;
            _modelingInfo.AICC = indiv.AICC;
            _modelingInfo.BIC = indiv.BIC;
            _modelingInfo.Press = indiv.Press;
            _modelingInfo.R2 = indiv.R2;
            _modelingInfo.RMSE = indiv.RMSE;
            _modelingInfo.Sensitivity = indiv.Sensitivity;
            _modelingInfo.Specificity = indiv.Specificity;
            _modelingInfo.VIF = indiv.VIF;

            _modelingInfo.SelectedModel = _selectedModelIndex;
            _modelingInfo.SetFitnessProgress(_listFitnessProgress);

            mlrPackState.Add("MLRModelingInfo", _modelingInfo);

            if (_dataMgr.ResidualAnalysisInfo == null)
                _dataMgr.ResidualAnalysisInfo = new ResidualAnalysisInfo();

            _dataMgr.ResidualAnalysisInfo.SelectedModelRMSE = indiv.RMSE;

            //string modelString = MLRCore.Support.BuildModelExpression(mlrIndiv.Model, _modelingInfo.DependentVariable, "g4");
            //mlrPackState.Add("ModelString", modelString);
            //mlrPackState.Add("Transform", _modelingInfo.DependentVariableTransform.ToString());
	        double dblRegulatoryThresholdTextbox, dblDecisionThresholdTextbox;
	        if (double.TryParse(tbDecThreshHoriz.Text, out dblDecisionThresholdTextbox) == false)
                dblDecisionThresholdTextbox = 235;
            if (double.TryParse(tbRegThreshVert.Text, out dblRegulatoryThresholdTextbox) == false)
                dblRegulatoryThresholdTextbox = 235;	    
	    
            //Pack up the textboxes that control modeling
            mlrPackState.Add("RegulatoryThreshold", dblRegulatoryThresholdTextbox);
            mlrPackState.Add("DecisionThreshold", dblDecisionThresholdTextbox);
            mlrPackState.Add("ThresholdTransformExponent", dblThresholdPowerTransformExponent);
            mlrPackState.Add("ThresholdTransform", xfrmThreshold);
            mlrPackState.Add("MaxVars", txtMaxVars.Text);
            mlrPackState.Add("MaxVIF", txtMaxVIF.Text);
            mlrPackState.Add("PseudorandomSeed", txtSeed.Text);
            mlrPackState.Add("PopulationSize", txtPopSize.Text);
            mlrPackState.Add("NumGenerations", txtNumGen.Text);
            mlrPackState.Add("MutationRate", txtMutRate.Text);
            mlrPackState.Add("CrossoverRate", txtCrossoverRate.Text);
            mlrPackState.Add("SelectionCriterion", cbCriteria.SelectedItem.ToString());
            mlrPackState.Add("ActiveAlgorithmTab", tabControlModelGeneration.SelectedIndex);
            
            return mlrPackState;
        }


        //Reconstruct the saved modeling state
        public void UnpackProjectState(IDictionary<string, object> dictProjectState)
        {
            //Nothing to do here
            if (dictProjectState == null || dictProjectState.Keys.Count < 1)
                return;

            if (dictProjectState.ContainsKey("DecisionThreshold"))
                DecisionThreshold = Convert.ToDouble(dictProjectState["DecisionThreshold"]);

            if (dictProjectState.ContainsKey("RegulatoryThreshold"))
                 RegulatoryThreshold = Convert.ToDouble(dictProjectState["RegulatoryThreshold"]);

            if (dictProjectState.ContainsKey("ThresholdTransform"))
                ThresholdTransform = (DependentVariableTransforms)(Convert.ToDouble(dictProjectState["ThresholdTransform"]));

            if (dictProjectState.ContainsKey("ThresholdTransformExponent"))
                ThresholdTransformExponent = Convert.ToDouble(dictProjectState["ThresholdTransformExponent"]);

            ConvertThresholdsToModeledUnits();

            if (dictProjectState.ContainsKey("MaxVars"))
                txtMaxVars.Text = dictProjectState["MaxVars"].ToString();

            if (dictProjectState.ContainsKey("MaxVIF"))
                txtMaxVIF.Text = dictProjectState["MaxVIF"].ToString();

            if (dictProjectState.ContainsKey("PseudorandomSeed"))
                txtSeed.Text = dictProjectState["PseudorandomSeed"].ToString();

            if (dictProjectState.ContainsKey("PopulationSize"))
                txtPopSize.Text = dictProjectState["PopulationSize"].ToString();

            if (dictProjectState.ContainsKey("NumGenerations"))
                txtNumGen.Text = dictProjectState["NumGenerations"].ToString();

            if (dictProjectState.ContainsKey("MutationRate"))
                txtMutRate.Text = dictProjectState["MutationRate"].ToString();

            if (dictProjectState.ContainsKey("CrossoverRate"))
                txtCrossoverRate.Text = dictProjectState["CrossoverRate"].ToString();

            if (dictProjectState.ContainsKey("SelectionCriterion"))
                cbCriteria.SelectedItem = dictProjectState["SelectionCriterion"].ToString();

            if (dictProjectState.ContainsKey("ActiveAlgorithmTab"))
                tabControlModelGeneration.SelectedIndex = Convert.ToInt32(dictProjectState["ActiveAlgorithmTab"].ToString());
            
            if (dictProjectState.ContainsKey("VariableSelection"))
            {
                //We must conver the variable selection state from its JSON representation first.
                object varSelectionState = dictProjectState["VariableSelection"];
                if (varSelectionState.GetType().ToString() == "Newtonsoft.Json.Linq.JObject")
                {
                    string strJson = varSelectionState.ToString();
                    Dictionary<string, List<ListItem>> varSelectionPackedState = Newtonsoft.Json.JsonConvert.DeserializeObject<Dictionary<string, List<ListItem>>>(strJson);
                    UnpackVariableSelectionState(varSelectionPackedState);
                }
            }

            if (dictProjectState.ContainsKey("PredPlot1"))
            {
                //We must conver the variable selection state from its JSON representation first.
                object jsonPredPlotState = dictProjectState["PredPlot1"];
                if (jsonPredPlotState.GetType().ToString() == "Newtonsoft.Json.Linq.JObject")
                {
                    string strJson = jsonPredPlotState.ToString();
                    Dictionary<string, object> dictPredPlotState = Newtonsoft.Json.JsonConvert.DeserializeObject<Dictionary<string, object>>(strJson);
                    mlrPlots1.UnpackState(dictPredPlotState);
                }
            }

            if (dictProjectState.ContainsKey("PredPlot2"))
            {
                //We must conver the variable selection state from its JSON representation first.
                object jsonPredPlotState = dictProjectState["PredPlot2"];
                if (jsonPredPlotState.GetType().ToString() == "Newtonsoft.Json.Linq.JObject")
                {
                    string strJson = jsonPredPlotState.ToString();
                    Dictionary<string, object> dictPredPlotState = Newtonsoft.Json.JsonConvert.DeserializeObject<Dictionary<string, object>>(strJson);
                    mlrPlots2.UnpackState(dictPredPlotState);
                }
            }

            MLRModelingInfo mi = null;
            object jsonObj = null;
            if (dictProjectState.ContainsKey("MLRModelingInfo"))
            {
                jsonObj = dictProjectState["MLRModelingInfo"] as object;
                if (jsonObj.GetType().ToString() == "Newtonsoft.Json.Linq.JObject")
                {
                    string strJson = jsonObj.ToString();
                    mi = Newtonsoft.Json.JsonConvert.DeserializeObject<MLRModelingInfo>(strJson);                    
                }
            }
            
            if (mi == null)
                return;

            Dictionary<string, double> model = null;
            if (dictProjectState.ContainsKey("MLRModel"))
            {
                jsonObj = dictProjectState["MLRModel"] as object;
                if (jsonObj.GetType().ToString() == "Newtonsoft.Json.Linq.JObject")
                {
                    string strJson = jsonObj.ToString();
                    model = Newtonsoft.Json.JsonConvert.DeserializeObject<Dictionary<string, double>>(strJson);
                }                
            }

            List<List<string>> chromosomes = null;
            if (dictProjectState.ContainsKey("MLRIndividualChromosomes"))
            {
                jsonObj = dictProjectState["MLRIndividualChromosomes"] as object;
                if (jsonObj.GetType().ToString() == "Newtonsoft.Json.Linq.JArray")
                {
                    string strJson = jsonObj.ToString();
                    chromosomes = Newtonsoft.Json.JsonConvert.DeserializeObject<List<List<string>>>(strJson);
                }  
            }
                                    
            listBox1.SelectedIndex = -1;
            _list = new List<IIndividual>();

            for (int i = 0; i < chromosomes.Count; i++)
            {
                MLRIndividual indiv = new MLRIndividual(chromosomes[i].Count, mi.MaxGeneValue, (FitnessCriteria)mi.FitnessCriteria, mi.MaxVIF, mi.DecisionThreshold, mi.MandatedThreshold);
                indiv.Chromosome = new List<string>(chromosomes[i]);
                indiv.Evaluate();
                _list.Add(indiv);

                string item = String.Format("{0:F4}", indiv.Fitness);
                listBox1.Items.Add(item);
            }

            //Restore the Fitness Progress plot:
            //Console.WriteLine("Generation: " + generation.ToString() + "   Fitness: " + max.ToString());
            //Make sure that the curvelist has at least one curve
            InitProgressGraph();
            if (mi.FitnessProgressListX != null)
            {
                if (zedGraphControl1.GraphPane.CurveList.Count <= 0)
                    return;

                // Get the first CurveItem in the graph
                LineItem curve = zedGraphControl1.GraphPane.CurveList[0] as LineItem;
                if (curve == null)
                    return;

                // Get the PointPairList
                curve.Points = mi.GetFitnessProgress();

                // Keep the X scale at a rolling 30 second interval, with one
                // major step between the max X value and the end of the axis
                Scale xScale = zedGraphControl1.GraphPane.XAxis.Scale;
                if (mi.FitnessProgressListX.Last() > xScale.Max - xScale.MajorStep)
                {
                    xScale.Max = mi.FitnessProgressListX.Last() + xScale.MajorStep;
                }

                // Make sure the Y axis is rescaled to accommodate actual data
                zedGraphControl1.AxisChange();
                zedGraphControl1.Invoke((MethodInvoker)delegate { zedGraphControl1.Refresh(); });
                _listFitnessProgress = zedGraphControl1.GraphPane.CurveList[0].Points as IPointListEdit;
            }

            _numObs = _dtFull.Rows.Count;
            lblNumObs.Text = "Number of Observations: " + _numObs.ToString();

            int maxVar = _numObs / 5;            
            int recVar = Math.Min(((_numObs / 10) + 1), (_lstSelectedVariables.Count));
            lblMaxAndRecommended.Text = "Recommended: " + recVar.ToString() + ", Max: " + maxVar.ToString();
            lblCombinationCount.Text = "There are " + Combinations(Available: _lstSelectedVariables.Count, MaxSelect: Convert.ToInt32(txtMaxVars.Text)) + " possible variable combinations";

            InitResultsGraph();
                        
            listBox1.SelectedIndex = mi.SelectedModel;

            //Unpack the model "rebuilds"
            if (dictProjectState.ContainsKey("RebuildList") && dictProjectState.ContainsKey("RebuildResidualDict"))
            {
                //Make sure that unpacking models doesn't trigger the listBox2_SelectedIndexChanged event:
                listBox2.SelectedIndexChanged -= new System.EventHandler(this.listBox2_SelectedIndexChanged);

                //Unpack the rebuilds.
                object jsonRebuilds = dictProjectState["RebuildList"];
                if (jsonRebuilds.GetType().ToString() == "Newtonsoft.Json.Linq.JArray")
                {
                    Newtonsoft.Json.Linq.JArray ja = jsonRebuilds as Newtonsoft.Json.Linq.JArray;
                    List<MultipleRegression> listMlrRebuilds = new List<MultipleRegression>();

                    foreach (Newtonsoft.Json.Linq.JToken token in ja)
                    {
                        Dictionary<string, object> dictPackedMLR = token.ToObject<Dictionary<string, object>>();

                        MultipleRegression myModel = new MultipleRegression();
                        myModel.UnpackState(dictPackedMLR);
                        listMlrRebuilds.Add(myModel);
                    }
                    _listRebuilds = listMlrRebuilds;
                }

                //Unpack the dictionary that stores residual types for the rebuilds.
                Dictionary<int, string> listRebuildResids = new Dictionary<int, string>();
                object jsonRebuildResidualDict = dictProjectState["RebuildResidualDict"];
                if (jsonRebuildResidualDict.GetType().ToString() == "Newtonsoft.Json.Linq.JObject")
                {
                    Newtonsoft.Json.Linq.JObject jo = jsonRebuildResidualDict as Newtonsoft.Json.Linq.JObject;
                    listRebuildResids = jo.ToObject<Dictionary<int, string>>();
                }

                //Link the restored rebuilds to listBox2:
                for (int i = 1; i < _listRebuilds.Count; i++)
                {
                    MultipleRegression rebuild = _listRebuilds[i];
                    UpdateModelList(rebuild, "rebuild", rebuild.Data, listRebuildResids[i]);
                }

                //update the plugin to reflect the rebuild that was selected when the project was saved, then reconnect the event handler.
                listBox2.SelectedIndex = mi.SelectedRebuildIndex;
                this.listBox2_SelectedIndexChanged(null, null);
                listBox2.SelectedIndexChanged += new System.EventHandler(this.listBox2_SelectedIndexChanged);                
            }
        }


        private string Combinations(int Available, int MaxSelect)
        {
            if (Available == MaxSelect)
            {
                return (Math.Pow(2, Available) - 1).ToString();
            }
            else
            {
                double num = Factorial(Available);
                double sum = 0;

                for (int i = 0; i <= MaxSelect; i++)
                {
                    sum = sum + num / Factorial(i) / Factorial(Available - i);
                }

                return (sum-1).ToString();
            }
        }


        private double Factorial(int n)
        {
            if (n <= 0)
            {
                return 1;
            }
            else
            {
                return n * Factorial(n - 1);
            }
        }


        //This function creates a datatable with only subset of selected IVs included in it.
        //Can't remeber the motivation for this.  Performance?
        private DataTable CreateModelDataTable()
        {
            DataTable dtCorr = _dtFull;
            DataView dvCorr = dtCorr.DefaultView;

            List<string> list = new List<string>();

            list.Add(dtCorr.Columns[0].ColumnName);
            list.Add(_dataMgr.ModelDependentVariable);

            int numVars = _lstSelectedVariables.Count;
            for (int i = 0; i < numVars; i++)
                list.Add(_lstSelectedVariables[i].ToString());

            DataTable dt = dvCorr.ToTable("ModelData", false, list.ToArray());

            return dt;
        }


        private bool VerifyGAModelParams()
        {
            _numVars = _lstSelectedVariables.Count;
            int numRecommendedVars = _numObs / 5;

            if (chkSeed.Checked)
            {
                if (Int32.TryParse(txtSeed.Text, out _seed) == false)
                {
                    string msg = "Seed must be a valid integer";
                    MessageBox.Show(msg);
                    return false;
                }
            }

            _totVar = _numVars;
            return true;
        }


        private bool VerifyManualModelParams()
        {
            return true;
        }


        private bool verifyGlobalModelingParams()
        {
            try
            {
                _numVars = _lstSelectedVariables.Count;
                int numRecommendedVars = _numObs / 5;
                _userSpecifiedNumVars = Convert.ToInt32(txtMaxVars.Text);

                if (_userSpecifiedNumVars > numRecommendedVars)
                {
                    string msg;
                    msg = "The maximum number of variables in model for this dataset (" + _numObs.ToString() + " observations)" + Environment.NewLine;
                    msg += " is " + numRecommendedVars.ToString() + ".";
                    MessageBox.Show(msg);
                    //txtMaxVars.Focus();                
                    return false;
                }
                if (_userSpecifiedNumVars > _numVars)
                {
                    string msg = "The maximum number of variables in model is limited to the number of independent variables in the list.";
                    MessageBox.Show(msg);
                    _userSpecifiedNumVars = _numVars;
                    //txtMaxVars.Text = _numVars.ToString();
                    //txtMaxVars.Focus();
                    return false;
                }

                if (_userSpecifiedNumVars < 1)
                {
                    MessageBox.Show("Maximum number of variables must be an integer value > 1.");
                    return false;
                }

                if (double.TryParse(tbDecThreshHoriz.Text, out _decisionThreshold) == false)
                {
                    string msg = @"Decision criterion must be a numeric value.";
                    MessageBox.Show(msg);
                    return false;
                }
                else if (double.TryParse(tbRegThreshVert.Text, out _mandateThreshold) == false)
                {
                    string msg = @"Regulatory standard must be a numeric value.";
                    MessageBox.Show(msg);
                    return false;
                }
                else
                {
                    mlrPlots1.SetThresholds(tbDecThreshHoriz.Text, tbRegThreshVert.Text);
                    mlrPlots1.DependentVarXFrm = _depVarTransform;
                    mlrPlots1.PowerTransformExponent = _depVarPowerTransformExponent;

                    mlrPlots2.SetThresholds(tbDecThreshHoriz.Text, tbRegThreshVert.Text);
                    mlrPlots2.DependentVarXFrm = _depVarTransform;
                    mlrPlots2.PowerTransformExponent = _depVarPowerTransformExponent;

                    if (rbLog10ValMET.Checked)
                    {
                        _decisionThreshold = Apply.UntransformThreshold(_decisionThreshold, DependentVariableTransforms.Log10);
                        _mandateThreshold = Apply.UntransformThreshold(_mandateThreshold, DependentVariableTransforms.Log10);
                        mlrPlots1.Transform = VBCommon.Transforms.DependentVariableTransforms.Log10;
                        mlrPlots2.Transform = VBCommon.Transforms.DependentVariableTransforms.Log10;
                    }
                    else if (rbLogeValMET.Checked)
                    {
                        _decisionThreshold = Apply.UntransformThreshold(_decisionThreshold, DependentVariableTransforms.Ln);
                        _mandateThreshold = Apply.UntransformThreshold(_mandateThreshold, DependentVariableTransforms.Ln);
                        mlrPlots1.Transform = VBCommon.Transforms.DependentVariableTransforms.Ln;
                        mlrPlots2.Transform = VBCommon.Transforms.DependentVariableTransforms.Ln;
                    }
                    else if (rbPwrValMET.Checked)
                    {
                        double pwr;
                        if (double.TryParse(txtPwrValMET.Text, out pwr) == false)
                        {
                            string msg = @"Power exponent must be a numeric value.";
                            MessageBox.Show(msg);
                            return false;
                        }

                        _decisionThreshold = Apply.UntransformThreshold(_decisionThreshold, DependentVariableTransforms.Power, pwr);
                        _mandateThreshold = Apply.UntransformThreshold(_mandateThreshold, DependentVariableTransforms.Power, pwr);
                        mlrPlots1.Transform = VBCommon.Transforms.DependentVariableTransforms.Power;
                        mlrPlots1.PowerExponent = pwr;

                        mlrPlots2.Transform = VBCommon.Transforms.DependentVariableTransforms.Power;
                        mlrPlots2.PowerExponent = pwr;
                    }
                    else
                    {
                        _decisionThreshold = Apply.UntransformThreshold(_decisionThreshold, DependentVariableTransforms.none);
                        _mandateThreshold = Apply.UntransformThreshold(_mandateThreshold, DependentVariableTransforms.none);
                        mlrPlots1.Transform = VBCommon.Transforms.DependentVariableTransforms.none;
                        mlrPlots2.Transform = VBCommon.Transforms.DependentVariableTransforms.none;
                    }

                    if (_depVarTransform == DependentVariableTransforms.Power)
                    {
                        _decisionThreshold = Apply.TransformThreshold(_decisionThreshold, _depVarTransform, _depVarPowerTransformExponent);
                        _mandateThreshold = Apply.TransformThreshold(_mandateThreshold, _depVarTransform, _depVarPowerTransformExponent);
                    }
                    else
                    {
                        _decisionThreshold = Apply.TransformThreshold(_decisionThreshold, _depVarTransform);
                        _mandateThreshold = Apply.TransformThreshold(_mandateThreshold, _depVarTransform);
                    }

                    if (_decisionThreshold < 0 || _decisionThreshold.Equals(double.NaN))
                    {
                        string msg = @"Decision criterion must be a numeric value greater than 0.";
                        MessageBox.Show(msg);
                        return false;
                    }

                    if (_mandateThreshold < 0 || _mandateThreshold.Equals(double.NaN))
                    {
                        string msg = @"Regulatory standard must be a numeric value greater than 0.";
                        MessageBox.Show(msg);
                        return false;
                    }
                }

                if (Int32.TryParse(txtMaxVIF.Text, out _maxVIF) == false)
                {
                    string msg = "Maximum Variance Inflation Factor (VIF) must be a valid integer";
                    MessageBox.Show(msg);
                    return false;
                }
            }
            catch { return false; }

            return true;
        }


        public void SetData()
        {
            _dtFull = MLRDataManager.GetDataManager().ModelDataTable.Copy();
            EstablishValidVariables(_dtFull);

            string exp = _dtFull.Columns[MLRDataManager.GetDataManager().ModelDependentVariable].ExtendedProperties[VBCommon.Globals.DEPENDENTVARIBLEDEFINEDTRANSFORM].ToString();
            string[] components = exp.Split(",".ToCharArray());

            _depVarTransform = (DependentVariableTransforms)Enum.Parse(typeof(DependentVariableTransforms),components[0]);

            if (_depVarTransform == DependentVariableTransforms.Power)
                _depVarPowerTransformExponent = Convert.ToDouble(components[1]);

            //Make sure that the scatterplots know how the dependent variable is transformed.
            mlrPlots1.DependentVarXFrm = _depVarTransform;
            mlrPlots1.PowerTransformExponent = _depVarPowerTransformExponent;

            mlrPlots2.DependentVarXFrm = _depVarTransform;
            mlrPlots2.PowerTransformExponent = _depVarPowerTransformExponent;

            if (_dtFull == null)
                return;

            tabControl1.SelectedIndex = 0;

            _numObs = _dtFull.Rows.Count;
            lblNumObs.Text = "Number of Observations: " + _numObs.ToString();

            int maxVar = _numObs / 5;
            int recVar = (_numObs / 10) + 1;
            lblMaxAndRecommended.Text = "Recommended: " + recVar.ToString() + ", Max: " + maxVar.ToString();

            mlrPlots1.SetThresholds(tbDecThreshHoriz.Text, tbRegThreshVert.Text);
            mlrPlots2.SetThresholds(tbDecThreshHoriz.Text, tbRegThreshVert.Text);
        }


        private double getTransformPower(string pwrTransform)
        {
            if (String.IsNullOrWhiteSpace(pwrTransform))
                return double.NaN;

            char[] delim = ",".ToCharArray();
            string[] svals = pwrTransform.Split(delim);

            double power = 1.0;
            if (svals.Length != 2)
                return double.NaN;

            if (!Double.TryParse(svals[1], out power))
                return double.NaN;

            return power;
        }
        

        private long CalcNumModels(long maxIndVars, long totalVars)
        {
            long numModels = 0;

            for (int i = 1; i <= maxIndVars; i++)
                numModels += VBCommon.Statistics.Utility.Choose(totalVars, i);

            return numModels;
        }


        private void RunManual()
        {
            ResetGraphs();
            ResetOutputFields();

            if (chkAllCombinations.Checked)
            {
                SearchExhaustiveModelList();
                return;
            }

            DataTable dt = _dataMgr.ModelDataTable;
            int numVars = _lstSelectedVariables.Count;
            FitnessCriteria fitnessCrit = GetFitnessCriteria();

            //Produce a single model
            MLRIndividual indiv = null;
            indiv = new MLRIndividual(numVars, numVars, fitnessCrit, _maxVIF, _decisionThreshold, _mandateThreshold);
            indiv.Chromosome = _lstSelectedVariables;
            indiv.Evaluate();

            if (indiv.IsViable())
            {
                _list = new List<IIndividual>();
                _list.Add(indiv);

                UpdateFitnessListBox();
                listBox1.SelectedIndex = 0;
            }
            else { System.Windows.Forms.MessageBox.Show("Can't build a model using these variables. Try using different variables."); }

            btnRun.Text = "Run";
            changeControlStatus(true);

            return;
        }


        private FitnessCriteria GetFitnessCriteria()
        {
            FitnessCriteria fitnessCriteria = FitnessCriteria.Akaike;

            string criteria = cbCriteria.SelectedItem as string;

            if (String.Compare(criteria, "Akaike Information Criterion (AIC)", true) == 0)
                fitnessCriteria = FitnessCriteria.Akaike;
            else if (String.Compare(criteria, "Adjusted R Squared", true) == 0)
                fitnessCriteria = FitnessCriteria.AdjustedR2;
            else if (String.Compare(criteria, "Corrected Akaike Information Criterion (AICC)", true) == 0)
                fitnessCriteria = FitnessCriteria.AICC;
            else if (String.Compare(criteria, "Bayesian Information Criterion (BIC)", true) == 0)
                fitnessCriteria = FitnessCriteria.BIC;
            else if (String.Compare(criteria, "R Squared", true) == 0)
                fitnessCriteria = FitnessCriteria.R2;
            else if (String.Compare(criteria, "PRESS", true) == 0)
                fitnessCriteria = FitnessCriteria.Press;
            else if (String.Compare(criteria, "Specificity", true) == 0)
                fitnessCriteria = FitnessCriteria.Specificity;
            else if (String.Compare(criteria, "Sensitivity", true) == 0)
                fitnessCriteria = FitnessCriteria.Sensitivity;
            else if (String.Compare(criteria, "Accuracy", true) == 0)
                fitnessCriteria = FitnessCriteria.Accuracy;
            else if (String.Compare(criteria, "Root Mean Square Error (RMSE)", true) == 0)
                fitnessCriteria = FitnessCriteria.RMSE;
            else
                throw new Exception("Invalid Fitness Criteria");

            return fitnessCriteria;
        }


        private void RunGA()
        {
            _dataMgr.ModelRunning = true;

            ResetGraphs();
            ResetOutputFields();

            double crossoverRate = Convert.ToDouble(txtCrossoverRate.Text);
            double mutationRate = Convert.ToDouble(txtMutRate.Text);
            int numGen = Convert.ToInt32(txtNumGen.Text);
            int popSize = Convert.ToInt32(txtPopSize.Text);

            FitnessCriteria fitnessCriteria = GetFitnessCriteria();

            _maxIndVars = Convert.ToInt32(txtMaxVars.Text);


            if (chkSeed.Checked)
            {
                int seed = Convert.ToInt32(txtSeed.Text);
                RandomNumbers.SetRandomSeed(seed);
            }
            else
                RandomNumbers.SetRandomSeed();

            _maxVIF = Convert.ToInt32(txtMaxVIF.Text);
            
            List<IIndividual> initPop = new List<IIndividual>(popSize);
            for (int i = 0; i < popSize; i++)
            {
                initPop.Add(new MLRIndividual(_maxIndVars, _totVar, fitnessCriteria, _maxVIF, _decisionThreshold, _mandateThreshold));
            }

            Population population = new Population(initPop);
            population.Initialize();
            population.CrossoverMethod = new MLROnePointCrossover(crossoverRate);

            if (fitnessCriteria == FitnessCriteria.Akaike)
            {
                population.Comparer = new AscendSort();
                AICSelector aicSelector = new AICSelector();
                aicSelector.Comparer = population.Comparer;
                population.Selector = aicSelector;
            }
            else if (fitnessCriteria == FitnessCriteria.AICC)
            {
                population.Comparer = new AscendSort();
                AICCSelector aiccSelector = new AICCSelector();
                aiccSelector.Comparer = population.Comparer;
                population.Selector = aiccSelector;
            }
            else if (fitnessCriteria == FitnessCriteria.BIC)
            {
                population.Comparer = new AscendSort();
                BICSelector bicSelector = new BICSelector();
                bicSelector.Comparer = population.Comparer;
                population.Selector = bicSelector;
            }
            else if (fitnessCriteria == FitnessCriteria.Press)
            {
                population.Comparer = new AscendSort();
                PressSelector pressSelector = new PressSelector();
                pressSelector.Comparer = population.Comparer;
                population.Selector = pressSelector;
            }
            else if (fitnessCriteria == FitnessCriteria.AdjustedR2)
            {
                population.Comparer = new DescendSort();
                AdjR2Selector adjR2Selector = new AdjR2Selector();
                adjR2Selector.Comparer = population.Comparer;
                population.Selector = adjR2Selector;
            }
            else if (fitnessCriteria == FitnessCriteria.R2)
            {
                population.Comparer = new DescendSort();
                R2Selector r2Selector = new R2Selector();
                r2Selector.Comparer = population.Comparer;
                population.Selector = r2Selector;
            }
            else if (fitnessCriteria == FitnessCriteria.RMSE)
            {
                population.Comparer = new AscendSort();
                RMSESelector rmseSelector = new RMSESelector();
                rmseSelector.Comparer = population.Comparer;
                population.Selector = rmseSelector;
            }
            else if (fitnessCriteria == FitnessCriteria.Sensitivity)
            {
                population.Comparer = new DescendSort();
                SensitivitySelector sensitivitySelector = new SensitivitySelector();
                sensitivitySelector.Comparer = population.Comparer;
                population.Selector = sensitivitySelector;
            }
            else if (fitnessCriteria == FitnessCriteria.Specificity)
            {
                population.Comparer = new DescendSort();
                SpecificitySelector specificitySelector = new SpecificitySelector();
                specificitySelector.Comparer = population.Comparer;
                population.Selector = specificitySelector;
            }
            else if (fitnessCriteria == FitnessCriteria.Accuracy)
            {
                population.Comparer = new DescendSort();
                AccuracySelector accuracySelector = new AccuracySelector();
                accuracySelector.Comparer = population.Comparer;
                population.Selector = accuracySelector;
            }
            
            population.ChromosomeComparer = new CompareChromosomes();
            population.Initialize();
            population.Mutator = new MLRMutator(mutationRate, _totVar);

            _gaManager = new GALib.GAManager();
            _gaManager.Init(population);
            _gaManager.NumberOfGenerations = numGen;
            _gaManager.GAProgress += new GAManager.GAProgressHandler(GAUpdate);
            _gaManager.GAComplete += new GAManager.GACompleteHandler(GAComplete);

            GAManager ga = new GAManager();
            _runThread = new Thread(_gaManager.Run);
            _runThread.Start();
        }


        private void btnRun_Click(object sender, EventArgs e)
        {
            _state = _mlrState.dirty;
            _pmi = -1;
            _modelingInfo = null;

            if (btnRun.Text == "Run")
            {
                if (verifyGlobalModelingParams() == false)
                    return;

                if (tabControlModelGeneration.SelectedTab.Name == "tabGA")
                {
                    if (VerifyGAModelParams() == false)
                        return;

                    _dataMgr.ModelDataTable = CreateModelDataTable();
                    _cancelRun = false;
                    btnRun.Text = "Cancel";
                    changeControlStatus(false);
                    RunGA();
                }
                else if (tabControlModelGeneration.SelectedTab.Name == "tabManual")
                {
                    _dataMgr.ModelDataTable =  CreateModelDataTable();
                    _cancelRun = false;
                    btnRun.Text = "Cancel";
                    changeControlStatus(false);
                    RunManual();
                }
                else if (tabControlModelGeneration.SelectedTab.Name == "tabStepwise")
                {
                    _dataMgr.ModelDataTable = CreateModelDataTable();
                }
            }
            else if (btnRun.Text == "Cancel")
            {
                _cancelRun = true;
                if (_gaManager != null)
                    _gaManager.Cancel = true;

                if (_esManager != null)
                    _esManager.Cancel = true;

                btnRun.Text = "Run";
                changeControlStatus(true);
                Application.DoEvents();
                return;
            }
            Application.DoEvents();
        }


        private void InitResultsGraph()
        {
            GraphPane myPane = zedGraphControl2.GraphPane;
            if (myPane.CurveList.Count > 0)
                myPane.CurveList.RemoveRange(0, myPane.CurveList.Count);

            myPane.Title.Text = "Results";
            myPane.XAxis.Title.Text = "X";
            myPane.YAxis.Title.Text = "Y";

            PointPairList list = new PointPairList();
            PointPairList list2 = new PointPairList();
            //Threshold line
            PointPairList list3 = new PointPairList();

            // Initially, a curve is added with no data points (list is empty)
            // Color is blue, and there will be no symbols

            LineItem curve = myPane.AddCurve("YObs", list, Color.Black, SymbolType.Square);
            curve.Line.IsVisible = true; // Hide the symbol outline            
            curve.Symbol.Border.IsVisible = true; // Fill the symbol interior with color
            
            LineItem curve2 = myPane.AddCurve("YPred", list2, Color.Red, SymbolType.Triangle);
            curve2.Line.IsVisible = true;

            LineItem curve3 = myPane.AddCurve("Threshold", list3, Color.Blue, SymbolType.None);
            curve3.Line.IsVisible = true;                       
            
            // Just manually control the X axis range so it scrolls continuously
            // instead of discrete step-sized jumps
            myPane.XAxis.Scale.Min = 0;
            myPane.XAxis.Scale.Max = 60;
            myPane.XAxis.Scale.MinorStep = 1;
            myPane.XAxis.Scale.MajorStep = 5;
                        
            // Scale the axes
            zedGraphControl2.AxisChange();
            zedGraphControl2.Refresh();
        }


        private void ResetGraphs()
        {
            _listFitnessProgress = null;
            GraphPane myPane = zedGraphControl1.GraphPane;
            LineItem curve = zedGraphControl1.GraphPane.CurveList[0] as LineItem;
            IPointListEdit list = curve.Points as IPointListEdit;
            list.Clear();

            //zedGraphControl2.GraphPane.CurveList.Clear();
            mlrPlots1.ZGC.GraphPane.CurveList.Clear();
            mlrPlots1.LISTVIEW.Items.Clear();            
        }


        private void ResetOutputFields()
        {
            listBox1.Items.Clear();
            listView1.Items.Clear();
            listView2.Items.Clear();

            //init residual stuff
            listBox2.Items.Clear();
            dgvResid.DataSource = null;
            zgcResidualsPlot.GraphPane.CurveList.Clear();
            zgcResidvFitted.GraphPane.CurveList.Clear();
            mlrPlots2.ZGC.GraphPane.CurveList.Clear();
            mlrPlots2.LISTVIEW.Items.Clear();            
        }


        private void InitProgressGraph()
        {
            GraphPane myPane = zedGraphControl1.GraphPane;

            if (tabControlModelGeneration.SelectedTab.Name == "tabGA")
            {
                myPane.Title.Text = "Genetic Algorithm Dynamic Fitness Update";

                myPane.XAxis.Title.Text = "Percent of Generations Completed";
                myPane.YAxis.Title.Text = "Fitness";
            }
            else if (tabControlModelGeneration.SelectedTab.Name == "tabManual")
            {
                myPane.Title.Text = "Exhaustive Search of Independent Variable Space\n" +
                    "(Percent Complete)";

                myPane.XAxis.Title.Text = "Percent Completed";
                myPane.YAxis.Title.Text = "Fitness";
            }
            
            // Save 1200 points.  At 50 ms sample rate, this is one minute
            // The RollingPointPairList is an efficient storage class that always
            // keeps a rolling set of point data without needing to shift any data values
            RollingPointPairList list = new RollingPointPairList(1200);

            myPane.CurveList.Clear();
            // Initially, a curve is added with no data points (list is empty)
            // Color is blue, and there will be no symbols
            LineItem curve = myPane.AddCurve("Fitness", list, Color.Blue, SymbolType.None);

            // Just manually control the X axis range so it scrolls continuously
            // instead of discrete step-sized jumps
            myPane.XAxis.Scale.Min = 0;
            myPane.XAxis.Scale.Max = 30;
            myPane.XAxis.Scale.MinorStep = 1;
            myPane.XAxis.Scale.MajorStep = 5;

            // Scale the axes
            zedGraphControl1.AxisChange();
            zedGraphControl1.Refresh();
        }


        private void RunComplete(List<IIndividual> updateList)
        {
            _list = new List<IIndividual>();

            //Only keep 10 models at most in list
            if (updateList != null)
            {
                int numModels = Math.Min(10, updateList.Count);
                for (int i = 0; i < numModels; i++)
                    _list.Add(updateList[i]);
            }

            listBox1.Invoke((MethodInvoker)delegate
            {
                listBox1.Items.Clear();
            });

            string item = "";
            int lastm;
            if (_list.Count > 10) lastm = 10;

            else lastm = _list.Count;
            for (int i = 0; i < lastm; i++)
            {
                item = String.Format("{0:F4}", _list[i].Fitness);
                listBox1.Invoke((MethodInvoker)delegate
                {
                    listBox1.Items.Add(item);
                });
            }

            btnRun.Invoke((MethodInvoker)delegate
            {
                btnRun.Text = "Run";
            });

            _dataMgr.ModelRunning = false;
            changeControlStatus(true);

            listBox1.Invoke((MethodInvoker)delegate
            {
                //Default is to select the top model
                listBox1.SelectedIndex = 0;
            });
        }


        private void GAComplete(GAManager gaManager)
        {
            RunComplete(gaManager.Results);
        }


        private void RunUpdate(double generation, double max)
        {

            Console.WriteLine("Generation: " + generation.ToString() + "   Fitness: " + max.ToString());
            // Make sure that the curvelist has at least one curve
            if (zedGraphControl1.GraphPane.CurveList.Count <= 0)
                return;

            // Get the first CurveItem in the graph
            LineItem curve = zedGraphControl1.GraphPane.CurveList[0] as LineItem;
            if (curve == null)
                return;

            // Get the PointPairList
            _listFitnessProgress = curve.Points as IPointListEdit;

            // If this is null, it means the reference at curve.Points does not
            // support IPointListEdit, so we won't be able to modify it
            if (_listFitnessProgress == null)
                return;

            // Time is measured in seconds
            //double time = (Environment.TickCount - tickStart) / 1000.0;
            double time = generation;

            // 3 seconds per cycle
            _listFitnessProgress.Add(generation, max);

            // Keep the X scale at a rolling 30 second interval, with one
            // major step between the max X value and the end of the axis
            Scale xScale = zedGraphControl1.GraphPane.XAxis.Scale;
            if (time > xScale.Max - xScale.MajorStep)
            {
                xScale.Max = time + xScale.MajorStep;
                //xScale.Min = xScale.Max - 30.0;
            }

            // Make sure the Y axis is rescaled to accommodate actual data
            zedGraphControl1.AxisChange();
            //zedGraphControl1.Invalidate();
            //zedGraphControl1.Update();
            // Force a redraw
            //
            //listBox1.Refresh();
            zedGraphControl1.Invoke((MethodInvoker)delegate
            {
                zedGraphControl1.Refresh();
            });
        }


        private void GAUpdate(double generation, double max)
        {
            RunUpdate(generation, max);
        }


        public void ClearModelingTab()
        {
            InitializeComponent();
            _modelingInfo = null;
            tabPage1.Name = "";
            _dataMgr = MLRDataManager.GetDataManager();
            cbCriteria.SelectedIndex = 0;
        }


        private void UpdateResults(List<double[]> data)
        {
            DataTable dt = _dtFull;
            string[] tags = (from DataRow dr in dt.Rows select dr[0].ToString()).Cast<string>().ToArray();
            //DataTable dt = DataStore.GetDataTable();
            // Make sure that the curvelist has at least one curve
            if (zedGraphControl2.GraphPane.CurveList.Count <= 0)
                return;

            // Get the first CurveItem in the graph
            LineItem curve = zedGraphControl2.GraphPane.CurveList[0] as LineItem;
            if (curve == null)
                return;

            // Get the second CurveItem in the graph
            LineItem curve2 = zedGraphControl2.GraphPane.CurveList[1] as LineItem;
            if (curve2 == null)
                return;

            // Get the PointPairList
            IPointListEdit list = curve.Points as IPointListEdit;
            // If this is null, it means the reference at curve.Points does not
            // support IPointListEdit, so we won't be able to modify it
            if (list == null)
                return;

            // Get the PointPairList
            IPointListEdit list2 = curve2.Points as IPointListEdit;
            // If this is null, it means the reference at curve.Points does not
            // support IPointListEdit, so we won't be able to modify it
            if (list2 == null)
                return;

            list.Clear();
            list2.Clear();

            for (int i = 0; i < data.Count; i++)
            {
                list.Add(new PointPair(i + 1, data[i][0], tags[i]));
                list2.Add(new PointPair(i + 1, data[i][1], tags[i]));
            }

            LineItem curve3 = zedGraphControl2.GraphPane.CurveList[2] as LineItem;
            if (curve3 != null)
            {
                IPointListEdit list3 = curve3.Points as IPointListEdit;
                list3.Clear();
                list3.Add(0, _decisionThreshold);
                list3.Add(data.Count, _decisionThreshold);

                curve3.Line.IsVisible = true;
            }

            //mikec - get rid of the line at y=0...?
            GraphPane zgc2pane = zedGraphControl2.GraphPane;
            //...best I can do for now
            zgc2pane.XAxis.Cross = 0;
            
            // Make sure the Y axis is rescaled to accommodate actual data
            zedGraphControl2.AxisChange();
            zedGraphControl2.GraphPane.XAxis.Scale.Max = zedGraphControl2.GraphPane.CurveList[0].NPts;

            // Force a redraw
            zedGraphControl2.Invalidate();
            zedGraphControl2.IsShowPointValues = true;
            listBox1.Refresh();
            zedGraphControl2.Refresh();
            Application.DoEvents();
        }               
        

        private void listBox1_SelectedIndexChanged(object sender, EventArgs e)
        {
            _smi = listBox1.SelectedIndex;
            if (_smi != _pmi)
            {
                if (_pmi == -1)
                {
                    _state = _mlrState.clean;
                }
                else
                {
                    _state = _mlrState.dirty;
                }
                _pmi = _smi;
            }
            else
            {
                _state = _mlrState.clean;
            }

            listView1.Items.Clear();
            listView2.Items.Clear();
            _selectedRebuildIndex = -1;

            int idx = listBox1.SelectedIndex;
            MLRIndividual ind = (MLRIndividual)_list[idx];
            
            _selectedModelIndex = idx;

            //tell the main form to enable the model save/saveas menu selection buttons
            OnModelSelected(null);                        

            string[] item = null;
            ListViewItem lvi = null;

            int numColumns = ind.Parameters.Columns.Count;
            for (int i = 0; i < ind.Parameters.Rows.Count; i++)
            {
                item = new string[numColumns];
                item[0] = ind.Parameters.Rows[i][0].ToString();
                item[1] = formatNumber((double)ind.Parameters.Rows[i][1]);
                item[2] = formatNumber((double)ind.Parameters.Rows[i][2]);
                item[3] = formatNumber((double)ind.Parameters.Rows[i][3]);
                item[4] = formatNumber((double)ind.Parameters.Rows[i][4]);
                item[5] = formatNumber((double)ind.Parameters.Rows[i][5]);
                lvi = new ListViewItem(item);
                listView1.Items.Add(lvi);
            }

            DataTable dt = _dataMgr.ModelDataTable;
            int depVarIndx = dt.Columns.IndexOf(_dataMgr.ModelDependentVariable);

            int numRecords = dt.Rows.Count;
            if (numRecords != ind.PredictedValues.Length)
                return;

            List<double[]> data = new List<double[]>();
            double[] record = null;
            string[] tags = new string[numRecords];
            for (int i = 0; i < numRecords; i++)
            {
                record = new double[2];
                record[0] = Convert.ToDouble(dt.Rows[i][depVarIndx].ToString());
                record[1] = ind.PredictedValues[i];
                tags[i] = dt.Rows[i][0].ToString();
                data.Add(record);
            }

            //for plotting xyplot when transform radio buttons changed
            _XYPlotdata = data;

            item = new string[2];
            item[0] = "R Squared";
            item[1] = String.Format("{0:F4}", ind.R2);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "Adjusted R Squared";
            item[1] = String.Format("{0:F4}", ind.AdjustedR2);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "Akaike Information Criterion";
            item[1] = String.Format("{0:F4}", ind.AIC);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "Corrected AIC";
            item[1] = String.Format("{0:F4}", ind.AICC);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "Bayesian Info Criterion";
            item[1] = String.Format("{0:F4}", ind.BIC);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "PRESS";
            item[1] = String.Format("{0:F4}", ind.Press);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "RMSE";
            item[1] = String.Format("{0:F4}", ind.RMSE);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            if ((ind.DecisionThreshold != Double.NaN) && (ind.MandatedThreshold != Double.NaN))
            {
                item = new string[2];
                item[0] = "";
                item[1] = "";
                lvi = new ListViewItem(item);
                listView2.Items.Add(lvi);

                item = new string[2];
                //item[0] = "Decision Criterion";
                item[0] = "Transformed DC";
                item[1] = string.Format("{0:F4}", ind.DecisionThreshold);
                lvi = new ListViewItem(item);
                listView2.Items.Add(lvi);

                item = new string[2];
                //item[0] = "Regulatory Standard";
                item[0] = "Transformed RS";
                item[1] = string.Format("{0:F4}", ind.MandatedThreshold);
                lvi = new ListViewItem(item);
                listView2.Items.Add(lvi);

                ModelErrorCounts mec = new ModelErrorCounts();
                mec.getCounts(ind.DecisionThreshold, ind.MandatedThreshold, ind.PredictedValues, ind.ObservedValues);
                int fp = mec.FPCount;
                int fn = mec.FNCount;

                item = new string[2];
                item[0] = "False Positives";
                item[1] = string.Format("{0:n}", fp);
                lvi = new ListViewItem(item);
                listView2.Items.Add(lvi);

                item = new string[2];
                item[0] = "Specificity";
                item[1] = String.Format("{0:F4}", ind.Specificity);
                lvi = new ListViewItem(item);
                listView2.Items.Add(lvi);

                item = new string[2];
                item[0] = "False Negatives";
                item[1] = string.Format("{0:n}", fn);
                lvi = new ListViewItem(item);
                listView2.Items.Add(lvi);

                item = new string[2];
                item[0] = "Sensitivity";
                item[1] = String.Format("{0:F4}", ind.Sensitivity);
                lvi = new ListViewItem(item);
                listView2.Items.Add(lvi);

                item = new string[2];
                item[0] = "Accuracy";
                item[1] = String.Format("{0:F4}", ind.Accuracy);
                lvi = new ListViewItem(item);
                listView2.Items.Add(lvi);

                //for reporting/plotting
                ThresholdChecked = true;
            }
            else
            {
                //for reporting/plotting
                ThresholdChecked = false;
            }

            item = new string[2];
            item[0] = "";
            item[1] = "";
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "Number of Observations";
            item[1] = string.Format("{0}", numRecords);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            UpdateResults(data);
          
            _dataMgr.Model = ind.Model;
            dictPackedState = ProjectSave();

            ModelFitExceedances();

            mlrPlots1.UpdateResults(data, ind.RMSE, MLRPlots.Exceedance.model, tags);
            mlrPlots1.btnXYPlot_Click(null, null);

            _listRebuilds = new List<MultipleRegression>();

            ShowResiduals(ind);
            boolModelingComplete = true;
            
            if (ModelChanged != null) { ModelChanged(); }
        }


        private void ModelFitExceedances(double Threshold=-1)
        {
            if (_modelingInfo != null && _list != null)
            {
                //MLRPredPlugin has similar code for prediction exceedances
                DataTable dtMData = _dataMgr.ModelDataTable;
                DataView dv = dtMData.DefaultView;
                List<string> listVarsInModel = _modelingInfo.Model.Keys.ToList<string>();
                listVarsInModel.RemoveAt(0);
                DataTable dtModelVarVals = dv.ToTable("ModelVarVals", true, listVarsInModel.ToArray());

                int idx = listBox1.SelectedIndex;
                MLRIndividual ind = (MLRIndividual)_list[idx];

                double dblThreshold;
                if (Threshold == -1)
                    dblThreshold = ind.DecisionThreshold;
                else
                    dblThreshold = Threshold;

                //mlrPlots1.Exceedances = VBCommon.Statistics.Statistics.PExceedFits(dtModelVarVals, ind.PredictedValues, dblThreshold, ind.RMSE);
                string exceed = mlrPlots1._exceedance.ToString();
                if (exceed == "model")
                    mlrPlots1.Exceedances = VBCommon.Statistics.Statistics.PExceedFits(dtModelVarVals, ind.PredictedValues, dblThreshold, ind.RMSE);
                else if (exceed == "prediction")
                    mlrPlots1.Exceedances = VBCommon.Statistics.Statistics.PExceedPrediction(dtModelVarVals, ind.PredictedValues, dblThreshold, ind.RMSE);
            }
        }


        private void ModelRebuildFitExceedances(double Threshold=-1)
        {
            //if (_modelingInfo != null && listBox2.Items.Count>1)
            if (_modelingInfo != null && listBox2.Items.Count > 0 && listBox2.SelectedIndex >= 0)
            {
                DataTable dtMData = _modelBuildTables.Tables[listBox2.SelectedIndex];
                DataView dv = dtMData.DefaultView;
                List<string> listVarsInModel = _modelingInfo.Model.Keys.ToList<string>();
                listVarsInModel.RemoveAt(0);
                DataTable dtModelVarVals = dv.ToTable("ModelVarVals", true, listVarsInModel.ToArray());

                double dblThreshold;
                if (Threshold == -1)
                    dblThreshold = _decisionThreshold;
                else
                    dblThreshold = Threshold;

                int idx = listBox2.SelectedIndex;
                MultipleRegression ind = (MultipleRegression)_listRebuilds[idx];

                //mlrPlots2.Exceedances = VBCommon.Statistics.Statistics.PExceedFits(dtModelVarVals, ind.PredictedValues, dblThreshold, ind.RMSE);
                string exceed = mlrPlots2._exceedance.ToString();
                if (exceed == "model")
                    mlrPlots2.Exceedances = VBCommon.Statistics.Statistics.PExceedFits(dtModelVarVals, ind.PredictedValues, dblThreshold, ind.RMSE);
                else if (exceed == "prediction")
                    mlrPlots2.Exceedances = VBCommon.Statistics.Statistics.PExceedPrediction(dtModelVarVals, ind.PredictedValues, dblThreshold, ind.RMSE);
            }
        }

                        
        private void ESComplete(ExhaustiveSearchManager esManager)
        {
            RunComplete(esManager.Results);
        }

        
        private void ESUpdate(double progress, double max)
        {
            RunUpdate(progress, max);
        }


        private void SearchExhaustiveModelList()
        {
            _dataMgr.ModelRunning = true;

            FitnessCriteria fitnessCrit = GetFitnessCriteria();            
            int numVars = _lstSelectedVariables.Count;

            _esManager = new ExhaustiveSearchManager(numVars, fitnessCrit, _maxVIF, _decisionThreshold, _mandateThreshold, _userSpecifiedNumVars);            

            _esManager.ESProgress += new ExhaustiveSearchManager.ESProgressHandler(ESUpdate);
            _esManager.ESComplete += new ExhaustiveSearchManager.ESCompleteHandler(ESComplete);

            _runThread = new Thread(_esManager.Run);
            _runThread.Start();

            return;
        }


        private void UpdateFitnessListBox()
        {
            listBox1.Items.Clear();

            for (int i = 0; i < _list.Count; i++)
            {
                string item = "";
                //item = "Fitness:" + list[i].Fitness.ToString();
                item = String.Format("{0:F4}", _list[i].Fitness);
                //lbModels.Items.Add(item);
                listBox1.Items.Add(item);
            }
        }


        /// <summary>
        /// Calculate the total number of combinations availabl for the selected number of independent variables
        /// </summary>
        private void SetCombinations()
        {
            
            //int numVars = lbIndVariables.Items.Count;
            int numVars = _lstSelectedVariables.Count;

            List<short> combList = new List<short>();
            short tmp = 0;
            for (short i = 1; i <= numVars; i++)
            {
                //ListItem li = (ListItem)lbIndVariables.Items[i];
                //tmp = i;
                //tmp += Convert.ToInt16(li.ValueItem);
                combList.Add(i);
            }

            //long totalComb = 0;
            decimal totalComb = 0;
            Combinations<short> combinations = null;
            for (int i = 0; i < numVars; i++)
            {
                combinations = new Combinations<short>(combList.ToArray(), i, GenerateOption.WithoutRepetition);
                totalComb += combinations.Count;
            }

            string nModels = string.Empty;
            if (totalComb > 9999999999)
            {
                //lblnModels.Text = string.Format("{0:000e000}", totalComb);
                nModels = string.Format("{0:000e000}", totalComb);
            }
            else
            {
                if (totalComb < 0)
                {
                    //we've flipped the storage capacity (not of totalComb [decimal type good to 7.8(10)**28], something else)
                    //combinations.Count is only a long - probably this (max 9.2(10)**18)
                    nModels = " more than 9.2e018 ";
                }
                else
                {
                    //lblnModels.Text = string.Format("{0:#,###,###,###}", totalComb);
                    nModels = string.Format("{0:#,###,###,###}", totalComb);
                }
            }
        }


        private void chkAllCombinations_CheckedChanged(object sender, EventArgs e)
        {
            if (chkAllCombinations.Checked)
            {
                //lblCombinations.Visible = true;
            }
            else
            {
                // lblCombinations.Visible = false;
            }
            SetCombinations();
        }
        

        private void frmModel_Activated(object sender, EventArgs e)
        {            
            //if (_dtFull != null)
            //    lbDepVarName.Text = _dtFull.Columns[1].ColumnName.ToString();
        }


        private void tabControlModelGeneration_SelectedIndexChanged(object sender, EventArgs e)
        {
            InitProgressGraph();
        }


        public void CopyListViewToClipboard(ListView lv)
        {
            StringBuilder buffer = new StringBuilder();

            for (int i = 0; i < lv.Columns.Count; i++)
            {
                buffer.Append(lv.Columns[i].Text);
                buffer.Append("\t");
            }

            buffer.Append(Environment.NewLine);

            for (int i = 0; i < lv.Items.Count; i++)
            {
                if (lv.Items[i].Selected)
                {
                    for (int j = 0; j < lv.Columns.Count; j++)
                    {
                        buffer.Append(lv.Items[i].SubItems[j].Text);
                        buffer.Append("\t");
                    }

                    buffer.Append(Environment.NewLine);
                }
            }
            Clipboard.SetText(buffer.ToString());
        }

        
        private void listView1_KeyDown(object sender, KeyEventArgs e)
        {
            if ((e.KeyCode == Keys.C) && (e.Modifiers == Keys.Control))
                CopyListViewToClipboard(listView1);
        }


        private void listView2_KeyDown(object sender, KeyEventArgs e)
        {
            if ((e.KeyCode == Keys.C) && (e.Modifiers == Keys.Control))
                CopyListViewToClipboard(listView2);
        }


        private void changeControlStatus(bool enable)
        {           
            groupBox4.Invoke((MethodInvoker)delegate
            {
                groupBox4.Enabled = enable;
            });

            tabControlModelGeneration.Invoke((MethodInvoker)delegate
            {
                tabControlModelGeneration.Enabled = enable;
            });

            cbCriteria.Invoke((MethodInvoker)delegate
            {
                cbCriteria.Enabled = enable;
            });

            chkSeed.Invoke((MethodInvoker)delegate
            {
                chkSeed.Enabled = enable;
            });

            txtSeed.Invoke((MethodInvoker)delegate
            {
                if (chkSeed.Checked)
                    txtSeed.Enabled = enable;
            });


            //txtDecisionThreshold.Invoke((MethodInvoker)delegate
            //{
            //    txtDecisionThreshold.Enabled = enable;
            //});

            //txtMandateThreshold.Invoke((MethodInvoker)delegate
            //{
            //    txtMandateThreshold.Enabled = enable;
            //});

            txtMaxVIF.Invoke((MethodInvoker)delegate
            {
                txtMaxVIF.Enabled = enable;
            });

            btnViewReport.Invoke((MethodInvoker)delegate
            {
                btnViewReport.Enabled = enable;
            });


        }


        private void frmModel_Validating(object sender, CancelEventArgs e)
        {
            if (_dataMgr.ModelRunning)
                e.Cancel = true;
        }


        private void txtMaxVars_Validating(object sender, CancelEventArgs e)
        {
            if (VerifyGAModelParams() == false)
                e.Cancel = true;

        }

        private void chkSeed_CheckedChanged(object sender, EventArgs e)
        {
            txtSeed.Enabled = chkSeed.Checked;
        }


        private void btnViewReport_Click(object sender, EventArgs e)
        {
            frmModelingReport frmRpt = new frmModelingReport();

            frmRpt.addHeader();

            FitnessCriteria fc = GetFitnessCriteria();
            string sfc = "Model Evaluation Criterion: " + fc.ToString() + "\n";
            frmRpt.addModelEvalCriterion(sfc);

            string[] models = new string[listBox1.Items.Count];
            listBox1.Items.CopyTo(models, 0);

            frmRpt.addList(models, _list);

            frmRpt.Show();
        }


        private void btnViewRptChangeStatus(bool status)
        {
            btnViewReport.Invoke((MethodInvoker)delegate
            {
                btnViewReport.Enabled = status;
            });
        }


        private void btnClearList_Click(object sender, EventArgs e)
        {
            //if (ClearList != null) ClearList(sender, e);
            ClearAllVariables();

            //for (int li = 0; li < lbIndVariables.Items.Count; li++)
            //    lbIndVariables.SetSelected(li, true);

            ////btnRemoveInputVariable_Click(this, new EventArgs());
            //List<ListItem> items = new List<ListItem>();

            //for (int i = 0; i < lbIndVariables.SelectedIndices.Count; i++)
            //{
            //    ListItem li = (ListItem)lbIndVariables.Items[lbIndVariables.SelectedIndices[i]];
            //    items.Add(li);
            //}

            //foreach (ListItem li in items)
            //{
            //    lbIndVariables.Items.Remove(li);

            //    bool foundIdx = false;
            //    int j = 0;
            //    for (j = 0; j < lbAvailableVariables.Items.Count; j++)
            //    {
            //        ListItem li2 = (ListItem)lbAvailableVariables.Items[j];
            //        if (Convert.ToInt32(li2.ValueItem) > Convert.ToInt32(li.ValueItem))
            //        {
            //            lbAvailableVariables.Items.Insert(j, li);
            //            foundIdx = true;
            //            break;
            //        }
            //    }
            //    if (foundIdx == false)
            //        lbAvailableVariables.Items.Insert(j, li);

            //}


            //SetCombinations();

            //lblAvailVars.Text = "(" + lbAvailableVariables.Items.Count.ToString() + ")";
            //lblDepVars.Text = "(" + lbIndVariables.Items.Count.ToString() + ")";
        }


        private void btnAddtoList_Click(object sender, EventArgs e)
        {
            if (listView1.Items.Count < 1) return;

            List<string> modelVars = new List<string>();
            for (int lvi = 1; lvi < listView1.Items.Count; lvi++)
            {
                string iv = listView1.Items[lvi].SubItems[0].Text;
                modelVars.Add(iv);
            }

            //MyEventArg myE = new MyEventArg();
            //myE.ModelVars = modelVars;
            

            //if (AddToList != null) AddToList(myE);
            //return;

            AddToList(modelVars);

            //if (lbAvailableVariables.SelectedItems.Count > 0)
                //btnAddInputVariable_Click(this, new EventArgs());

            //List<ListItem> items = new List<ListItem>();

            //int selectedIndices = lbAvailableVariables.SelectedIndices.Count;
            //for (int i = 0; i < selectedIndices; i++)
            //{
            //    ListItem li = (ListItem)lbAvailableVariables.Items[lbAvailableVariables.SelectedIndices[i]];
            //    items.Add(li);
            //}

            //foreach (ListItem li in items)
            //{
            //    lbAvailableVariables.Items.Remove(li);
            //    lbIndVariables.Items.Add(li);
            //}


            //SetCombinations();

            //lblAvailVars.Text = "(" + lbAvailableVariables.Items.Count.ToString() + ")";
            //lblDepVars.Text = "(" + lbIndVariables.Items.Count.ToString() + ")";
        }


        //private void lblDepVars_TextChanged(object sender, EventArgs e)
        private void SelectedVariablesChanged()
        {
            int availVar = _lstSelectedVariables.Count;
            int maxVar = Math.Min((_numObs / 5), availVar);
            int recVar = Math.Min(((_numObs / 10) + 1), availVar);

            lblMaxAndRecommended.Text = "Available: " + availVar.ToString() +
                ", Recommended: " + recVar.ToString() +
                ", Max: " + maxVar.ToString();

            txtMaxVars.Text = recVar.ToString();
            lblCombinationCount.Text = "There are " + Combinations(Available: _lstSelectedVariables.Count, MaxSelect: Convert.ToInt32(txtMaxVars.Text)) + " possible variable combinations";

            if (VariablesChanged != null)
            {
                VariablesChanged(this, new EventArgs());
            }
        }


        private void btnCrossValidation_Click(object sender, EventArgs e)
        {
            frmCrossValidation crossValForm = new frmCrossValidation(_list, _numObs);
            //crossValForm.ShowDialog(this);
            crossValForm.ShowDialog();
        }


        private void frmModel_HelpRequested(object sender, HelpEventArgs hlpevent)
        {
            string apppath = Application.StartupPath.ToString();
            VBCSHelp help = new VBCSHelp(apppath, sender);
            if (!help.Status)
            {
                MessageBox.Show(
                "User documentation is found in the Documentation folder where you installed Virtual Beach"
                + "\nIf your web browser is PDF-enabled, open the User Guide with your browser.",
                "Neither Adobe Acrobat nor Adobe Reader found.",
                MessageBoxButtons.OK);
            }
        }


        #region roc prototype;

        /// <summary>
        /// given a model and decision threshold calculate (and store) information for a roc curve
        /// </summary>
        /// <param name="model">mlr model</param>
        /// <param name="decisionThreshold">threshold value</param>
        /// <param name="rocPars">roc curve information </param>
        /// <returns>point pair for plotting</returns>
        private PointPair ROCpoint(MLRIndividual model, double decisionThreshold, out ROCParameters rocPars)
        {
            //for a given threshold and model, categorize predictions relative to observations
            //and calculate the sensitivity and specificity evaluation criteria, return theses
            //values as a zedgraph point.

            PointPair pp = new PointPair();
            double[] measurement = model.ObservedValues;
            double[] est = model.PredictedValues;

            int falsePos = 0;
            int falseNeg = 0;

            double specificity = double.NaN;
            double sensitivity = double.NaN;
            double accuracy = double.NaN;

            ModelErrorCounts mec = new ModelErrorCounts();
            mec.getCounts(decisionThreshold, _mandateThreshold, est, measurement);

            sensitivity = mec.Sensitivity;
            specificity = mec.Specificity;
            falsePos = mec.FPCount;
            falseNeg = mec.FNCount;
            accuracy = mec.Accuracy;
            
            if (!sensitivity.Equals(double.NaN) && !specificity.Equals(double.NaN))
            {
                pp.X = (1.0d - specificity);
                pp.Y = sensitivity;
            }

            //store the info for this decision threshold
            ROCParameters rocpars = new ROCParameters(decisionThreshold, sensitivity, specificity, falsePos, falseNeg, accuracy);
            rocPars = rocpars;

            return pp;
        }


        /// <summary>
        /// given a mlr model, vary the threshold by increments to find model sensitivity and specificity
        /// for each increment - these become roc plotting points for the model.  also, save the roc trace 
        /// data for passing to the caller for table display.  plotting points need to be sorted and aggregated
        /// (weedppl(ppl)) for calculating auc (area-under-curve via integration)
        /// </summary>
        /// <param name="model">given mlr model</param>
        /// <param name="rocTableVals"></param>
        /// <returns>null if number of pts lt 10, otherwise a pointpair list fro plotting</returns>
        private PointPairList ROCpoints(MLRIndividual model, out List<object> rocTableVals)
        {
            const int steps = 50;

            //vary the decision threshold by increments
            //calculate the ROC point for the decision threshold increment
            //accumulate points for all increments and return pointpairlist

            PointPairList ppl = new PointPairList();
            PointPair pp = new PointPair();
            ROCParameters rocParameters = null;
            List<object> rocTableVal = new List<object>();

            double maxPred = model.PredictedValues.Max();
            double minPred = model.PredictedValues.Min();
            double inc = (maxPred - minPred) / (double)steps;
            double threshold = minPred - inc;

            while (threshold <= maxPred + inc)
            {
                threshold += inc;
                pp = ROCpoint(model, threshold, out rocParameters);
                if (!pp.IsInvalid)
                {
                    ppl.Add(pp);
                    rocTableVal.Add(rocParameters.ROCPars);
                }
            }

            rocTableVals = rocTableVal;

            //how many points is the minimum???
            if (ppl.Count > 10)
            {
                //sort for integral calc
                ppl.Sort();
                //get rid of multiple X datapoints
                ppl = weedppl(ppl);
                if (ppl.Count == 1) { ppl.Add(ppl[0]); }
                return ppl;
            }
            else
            {
                return null;
            }
        }


        /// <summary>
        /// method aggregates a pointpair list Y values by X values, in effect removing duplicate X values
        /// this is required for the auc integration calculation (which crashes when x(i) == x(i+1), i.e. when
        /// delta x == 0)
        /// </summary>
        /// <param name="ppl"></param>
        /// <returns></returns>
        private PointPairList weedppl(PointPairList ppl)
        {
            //throw new NotImplementedException();

            //aggregate points by X values; Y becomes avarage of Ys for same Xs
            //prove yer smarter than me and implement this with linq...  ppl is already sorted by X ascending.
            PointPairList ppl2 = new PointPairList();

            //double[] x = new double[ppl.Count];
            //double[] y = new double[ppl.Count];

            double x, y, Ypp;
            double Xbase = ppl[0].X;
            double Ybase = ppl[0].Y;
            double Ytot = 0.0d;
            int ctr = 1;
            for (int i = 1; i < ppl.Count; i++)
            {
                x = ppl[i].X;
                y = ppl[i].Y;
                if (x == Xbase)
                {
                    Ytot = Ytot + y;
                    ctr++;
                    continue;
                }
                else
                {
                    Ypp = Ytot / (double)ctr;
                    ppl2.Add(Xbase, Ypp);  

                    ctr = 1;
                    Ytot = y;                                      
                    Xbase = x;
                }                
            }
            //Keep the final entry
            Ypp = Ytot / (double)ctr;
            ppl2.Add(Xbase, Ypp); 

            return ppl2;
        }


        /// <summary>
        /// generate roc plot data for all models in the best-fit models list and makes the plots.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void tabControl2_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (tabControl2.SelectedIndex == 3) //do nothing if not roc curves tab selected
            {
                if (listBox1.Items.Count < 1) return;

                if (_list.Count > 0) //if we have models, make plots
                {
                    double lowerbound = 0.0d;
                    double upperbound = 1.0d;
                    listView3.Items.Clear();
                    GraphPane pane = zgcROC.GraphPane;
                    if (pane.CurveList.Count > 0) pane.CurveList.Clear();
                    pane.Title.Text = "Receiver Operating Characteristic Curves \n for Best-Fit Models";
                    pane.XAxis.Title.Text = "1 - Specificity";
                    pane.YAxis.Title.Text = "Sensitivity";

                    object[] colors = new object[] {Color.DarkSeaGreen, Color.Green, Color.Indigo, 
                        Color.ForestGreen, Color.CadetBlue,
                        Color.DarkBlue, Color.DarkViolet, Color.DarkCyan, 
                        Color.Blue, Color.DarkGray};

                    object[] symbols = new object[] {SymbolType.Circle, SymbolType.Diamond, SymbolType.Plus,
                        SymbolType.Square, SymbolType.Star, SymbolType.Triangle,
                        SymbolType.TriangleDown, SymbolType.XCross, SymbolType.VDash, SymbolType.HDash};


                    string[] item = new string[2];

                    PointPairList ppl = new PointPairList();

                    //generate the data, make the plots, and fill the listbox with model/areaundercurve info
                    int maxmodelptr = -1;
                    double maxmodelauc = 0;

                    //if there are more models in list than showing... use 10 or use the number in the list
                    int maxNmodels = _list.Count <= 10 ? _list.Count : 10;

                    //initialize a structure for storing roc curve information for all curves...
                    _tableVals = new Dictionary<string,List<object>>();
                    //...and one for individual model
                    List<object> modelRocVals = null;

                    //for (int li = 0; li < list.Count; li++)
                    for (int li = 0; li < maxNmodels; li++)
                    {
                        //PointPairList ppl = ROCpoints( (MLRIndividual)list[li]);
                        ppl = ROCpoints((MLRIndividual)_list[li], out modelRocVals);
                        string key = _list[li].Fitness.ToString("##.####");
                        if (!_tableVals.ContainsKey(key))
                        {
                            _tableVals.Add(key, modelRocVals);
                        }
                        if (ppl != null && ppl.Count > 0)
                        {
                            //BasicArrayPointList ppl = ROCpoints((MLRIndividual)list[li]);
                            LineItem curve = pane.AddCurve(_list[li].Fitness.ToString("##.####"), ppl,
                                (Color)colors[li], (SymbolType)symbols[li]);

                            double[] X = new double[ppl.Count];
                            double[] Y = new double[ppl.Count];
                            for (int i = 0; i < ppl.Count; i++) //there must be a smarter way to do this
                            {
                                X[i] = ppl[i].X;
                                Y[i] = ppl[i].Y;
                            }

                            //performing integral evaluation with EM Piecewise constant curve instance
                            //(another possibility is the Piecewise linear curve class... splines and 
                            //other curve definitions seem like overkill and delegate realfunctions seem
                            //like the wrong approach entirely - requires curve fitting/definition and all
                            //we have are data points for VERY similar curves)
                            Calculus calc = new Calculus(X, Y, lowerbound, upperbound);
                            double auc = calc.PieceWiseLinearCurveIntegrate();

                            //maybe piecewise linear curve is better?
                            calc = new Calculus(X, Y, lowerbound, upperbound);
                            double auc2 = calc.PieceWiseLinearCurveIntegrate();
                            double idiff = auc - auc2;

                            //comment next line to use piecewiseconstant integral calc
                            auc = auc2;
                            
                            item[0] = _list[li].Fitness.ToString("##.####");
                            //item[1] = string.Format("{0:f6}", auc.ToString());
                            item[1] = auc.ToString("#.######");
                            ListViewItem lvi = new ListViewItem(item);
                            listView3.Items.Add(lvi);

                            if (auc > maxmodelauc)
                            {
                                maxmodelauc = auc;
                                maxmodelptr = li;
                            }
                        }
                    }

                    //add the no information trace
                    PointPair orig = new PointPair(0, 0);
                    PointPair extent = new PointPair(1, 1);
                    PointPairList ppl2 = new PointPairList();
                    ppl2.Add(orig);
                    ppl2.Add(extent);
                    LineItem curve2 = pane.AddCurve("", ppl2, Color.Black);
                    //curve2.Tag = "NoInfo";
                    curve2.IsVisible = true;

                    pane.XAxis.Scale.Max = 1.0;
                    pane.YAxis.Scale.Max = 1.0;
                    zgcROC.AxisChange();

                    if (pane.CurveList.Count > 1)
                    {
                        //highlight the max auc trace 
                        LineItem bestcurve = (LineItem)pane.CurveList[maxmodelptr];
                        //bestcurve.Symbol.Size = 12.0f;
                        bestcurve.Line.Width = 3.0f;
                        bestcurve.Line.Color = Color.Red;

                        //highlight the model with the max auc in the listbox
                        //listView3.Items[maxmodelptr].BackColor = Color.Pink;
                        listView3.Items[maxmodelptr].ForeColor = Color.Red;

                        //dump the roc parameters to the table (list)
                        string temp = listView3.Items[maxmodelptr].Text;
                        List<object> vals = _tableVals[temp];
                        updateList(vals);

                    }
                    else
                    {
                        MessageBox.Show("The current values for the decision criterion and regulatory standard do not permit ROC curves to be calculated.",
                            "No Appropriate Plot Data", MessageBoxButtons.OK);
                    }
                }
            }
        }

        /// <summary>
        /// populates the roc table (list) with information for the selected model
        /// </summary>
        /// <param name="data"></param>
        private void updateList(List<object> data)
        {
            listView4.Items.Clear();
            foreach (object element in data)
            {
                ROCParameters rocp = new ROCParameters((object[])element);
                string[] item = new string[7];
                //item[0] = rocp.DecisionThreshold.ToString("f4");
                item[0] = transformDC(rocp.DecisionThreshold);
                item[2] = rocp.FalsePosCount.ToString("n0");
                item[1] = rocp.FalseNegCount.ToString("n0");
                item[3] = (rocp.FalsePosCount + rocp.FalseNegCount).ToString("n0");
                //int tot = rocp.FalseNegCount + rocp.FalsePosCount;
                //item[3] = tot.ToString("n0");
                item[5] = rocp.Specificity.ToString("f4");
                item[4] = rocp.Sensitivity.ToString("f4");
                item[6] = rocp.Accuracy.ToString("f4");


                ListViewItem lvi = new ListViewItem(item);
                listView4.Items.Add(lvi);
            }

        }

        private string transformDC(double dc)
        {
            string sdc = string.Empty;
            double tdc;
            //if (Transform == Globals.DependentVariableTransforms.Log10)
            if (rbLog10ValMET.Checked)
            {
                tdc = Math.Pow(10.0d, dc);
            }
            //else if (Transform == Globals.DependentVariableTransforms.Ln)
            else if (rbLogeValMET.Checked)
            {
                tdc = Math.Pow(Math.E, dc);
            }
            //else if (Transform == Globals.DependentVariableTransforms.Power)
            else if (rbPwrValMET.Checked)
            {
                double power = Convert.ToDouble(txtPwrValMET.Text);
                tdc = Math.Pow(dc, power);
            }
            else //(Transform == Globals.DependentVariableTransforms.none)
            {
                tdc = dc;
            }

            sdc = tdc.ToString("n4");
            return sdc;
        }

        /// <summary>
        /// plots auc curves for selected models chosen from
        /// the model/auc list
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnROCPlot_Click(object sender, EventArgs e)
        {
            //do plot manipulations for user selected models
            if (_ndxs != null)
            {
                if (_ndxs.Length > 0) plotROCCurves();
            }
        }

        /// <summary>
        /// method for gathering an index list from the model/auc list
        /// of selected models for subsequent plotting of roc curves of 
        /// those selected
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void listView3_Leave(object sender, EventArgs e)
        {
            //collect a list of indicies of user selected models
            int[] ndxs = new int[listView3.SelectedIndices.Count];
            listView3.SelectedIndices.CopyTo(ndxs, 0);
            if (ndxs.Length > 0) _ndxs = ndxs;

        }

        /// <summary>
        /// method for getting the first selected model from the model/auc list
        /// and updating the roc table
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void listView3_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (listView3.SelectedItems.Count > 0)
            {
                ListViewItem li = listView3.SelectedItems[0];
                string modelName = li.Text;
                if (!string.IsNullOrWhiteSpace(modelName))
                {
                    List<object> vals = _tableVals[modelName];
                    updateList(vals);
                }
            }

        }

        /// <summary>
        /// method for copy/paste of the roc table functionality
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void listView4_KeyDown(object sender, KeyEventArgs e)
        {
            {
                if ((e.Modifiers & Keys.Control) != 0)
                {
                    if (e.KeyCode == Keys.C)
                    {
                        ////string s = string.Empty;
                        //string s = "Threshold\tFalsePos\tFalseNeg\tSpecificity\tSensitivity\n";
                        //foreach (ListViewItem item in listView4.Items)
                        //{
                        //    string si = string.Empty;
                        //    for (int i = 0; i < item.SubItems.Count; i++)
                        //    {
                        //        si += item.SubItems[i].Text + "\t";
                        //    }
                        //    s += si + "\n";

                        //}
                        //Clipboard.SetText(s);

                        //use kurt's code instead....
                        CopyListViewToClipboard(listView4);
                    }
                }
            }
        }

        /// <summary>
        /// visibility switcher for the roc plot or roc table
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnView_Click(object sender, EventArgs e)
        {
            if (btnView.Text == "View Table")
            {
                //plot is not visible, table is, toggle button text
                btnView.Text = "View Plot";
                listView4.Visible = true;
                zgcROC.Visible = false;
            }
            else if (btnView.Text == "View Plot")
            {
                //table is not visible, plot is, toggle button text
                btnView.Text = "View Table";
                listView4.Visible = false;
                zgcROC.Visible = true;
            }
        }

        /// <summary>
        /// performs plotting of roc curves.  actually, curves for all models are already plotted,
        /// this method just makes those not selected from the list invisible, others visible
        /// </summary>
        private void plotROCCurves()
        {
            //CurveItem visible/invisible switcher; provides UI clues in list of models as well

            GraphPane pane = zgcROC.GraphPane;

            for (int ci = 0; ci < pane.CurveList.Count; ci++)
            {
                CurveItem curve = pane.CurveList[ci];
                if (_ndxs.Contains(ci))
                {
                    curve.IsVisible = true;
                    listView3.Items[ci].BackColor = Color.Empty;
                }
                else
                {
                    curve.IsVisible = false;
                    if (ci < listView3.Items.Count) //need this for the noinfo curve - it's not in the list
                        listView3.Items[ci].BackColor = Color.LightGray;
                }
            }

            //turn the NoInfo curve back on
            pane.CurveList[""].IsVisible = true;

            zgcROC.Refresh();
        }

        #endregion;

                

        /// <summary>
        /// //tell main to enable the modelSave/SaveAs menu options
        /// </summary>
        /// <param name="e"></param>
        protected virtual void OnModelSelected(EventArgs e)
        {
            EventHandler eh = ModelSelected;
            if (eh != null) eh(this, e);
        }


        private void rbPwrValMET_CheckedChanged(object sender, EventArgs e)
        {
            if (rbPwrValMET.Checked)
            {
                txtPwrValMET.Enabled = true;
                xfrmThreshold = DependentVariableTransforms.Power;
            }
            else
                txtPwrValMET.Enabled = false;
        }


        private void rbValMET_CheckedChanged(object sender, EventArgs e)
        {
            if (rbValMET.Checked)
                xfrmThreshold = DependentVariableTransforms.none;
        }


        private void rbLog10ValMET_CheckedChanged(object sender, EventArgs e)
        {
            if (rbLog10ValMET.Checked)
                xfrmThreshold = DependentVariableTransforms.Log10;
        }


        private void rbLogeValMET_CheckedChanged(object sender, EventArgs e)
        {
            if (rbLogeValMET.Checked)
                xfrmThreshold = DependentVariableTransforms.Ln;
        }


        private void txtPwr_Leave(object sender, EventArgs e)
        {
            double power;
            TextBox txtBox = (TextBox)sender;

            if (!Double.TryParse(txtBox.Text, out power))
            {
                MessageBox.Show("Invalid number.");
                txtBox.Focus();
            }
            else
                dblThresholdPowerTransformExponent = Convert.ToDouble(txtPwrValMET.Text);
                _modelingInfo.ThresholdPowerTransformExponent = Convert.ToDouble(txtPwrValMET.Text);
        }

        private void txtPopSize_Validated(object sender, EventArgs e)
        {
            errorProvider1.SetError(txtPopSize, "");
        }

        private void txtPopSize_Validating(object sender, CancelEventArgs e)
        {
            int popSize;
            if (!int.TryParse(txtPopSize.Text, out popSize))
            {
                e.Cancel = true;
                txtPopSize.Select(0, txtPopSize.Text.Length);
                this.errorProvider1.SetError(txtPopSize, "Text must convert to an integer.");
                return;
            }

            if (popSize < 25)
            {
                e.Cancel = true;
                txtPopSize.Select(0, txtPopSize.Text.Length);
                this.errorProvider1.SetError(txtPopSize, "Population size must be 25 or greater.");
                return;
            }
        }

        private void txtNumGen_Validated(object sender, EventArgs e)
        {
            errorProvider1.SetError(txtNumGen, "");
        }

        private void txtNumGen_Validating(object sender, CancelEventArgs e)
        {
            int numGen;
            if (!int.TryParse(txtNumGen.Text, out numGen))
            {
                e.Cancel = true;
                txtNumGen.Select(0, txtNumGen.Text.Length);
                this.errorProvider1.SetError(txtNumGen, "Text must convert to an integer.");
                return;
            }

            if (numGen < 25)
            {
                e.Cancel = true;
                txtNumGen.Select(0, txtNumGen.Text.Length);
                this.errorProvider1.SetError(txtNumGen, "Number of generations must be 25 or greater.");
                return;
            }
        }

        private void txtMutRate_Validated(object sender, EventArgs e)
        {
            errorProvider1.SetError(txtMutRate, "");
        }

        private void txtMutRate_Validating(object sender, CancelEventArgs e)
        {
            double mutRate;
            if (!double.TryParse(txtMutRate.Text, out mutRate))
            {
                e.Cancel = true;
                txtMutRate.Select(0, txtMutRate.Text.Length);
                this.errorProvider1.SetError(txtMutRate, "Mutation rate must be a number between 0 and 1.");
                return;
            }

            if ((mutRate > 1.0) || (mutRate < 0.0))
            {
                e.Cancel = true;
                txtMutRate.Select(0, txtMutRate.Text.Length);
                this.errorProvider1.SetError(txtMutRate, "Mutation rate must be a number between 0 and 1.");
                return;
            }
        }

        private void txtCrossoverRate_Validating(object sender, CancelEventArgs e)
        {
            double crossRate;
            if (!double.TryParse(txtCrossoverRate.Text, out crossRate))
            {
                e.Cancel = true;
                txtCrossoverRate.Select(0, txtCrossoverRate.Text.Length);
                this.errorProvider1.SetError(txtCrossoverRate, "Crossover rate must be a number between 0 and 1.");
                return;
            }

            if ((crossRate > 1.0) || (crossRate < 0.0))
            {
                e.Cancel = true;
                txtCrossoverRate.Select(0, txtCrossoverRate.Text.Length);
                this.errorProvider1.SetError(txtCrossoverRate, "Crossover rate must be a number between 0 and 1.");
                return;
            }
        }

        private void txtCrossoverRate_Validated(object sender, EventArgs e)
        {
            errorProvider1.SetError(txtCrossoverRate, "");
        }


        #region residual tab controls and methods

        private void ShowResiduals(MLRIndividual selectedModel)
        {
            Dictionary<string, double> modeldic = _dataMgr.Model;

            if (_dataMgr.ModelDataTable == null) return;
            
            _residualInfo = new Dictionary<int, string>();
            _modelBuildTables = new DataSet();
            DataTable modeldt = _dataMgr.ModelDataTable;
            _gobtnState = true;

            //cutoff rebuilds when half data records eliminated
            _maxIterations = modeldt.Rows.Count / 2;

            if (modeldt != null)
            {
                MultipleRegression model = computeModel(modeldt);
                _listRebuilds.Add(model);

                if (model != null)
                {
                    //Make sure that clearing listBox2 doesn't trigger the listBox2_SelectedIndexChanged event:
                    listBox2.SelectedIndexChanged -= new System.EventHandler(this.listBox2_SelectedIndexChanged);

                    _recsRemoved = new List<int>();
                    _residValueRemoved = new List<double>();
                    _residTypeRemoved = new List<string>();
                    
                    listBox2.Items.Clear();
                    _modelBuildTables.Tables.Clear();

                    DataTable dffits = getDFFITSTable(model, modeldt, true);
                    DataTable cooks = getCooksDistanceTable(model, modeldt, true);
                    string[] tags = (from DataRow dr in model.Data.Rows select dr[0].ToString()).Cast<string>().ToArray();

                    string modelname = UpdateModelList(model, "original", modeldt, "model");
                    UpdateListViews(model, modelname);
                    createResidvFittedPlot(model, tags);  //predictions vs standardized residuals plot
                    
                    double dffitsThreshold = Convert.ToDouble((2.0d * Math.Sqrt(((double)(CreateResidualModelDataTable()).Columns.Count - 2) / (double)model.PredictedValues.Length)).ToString());
                    double cooksThreshold = 4.0d / (double)model.PredictedValues.Length;

                    setLabels(true, dffitsThreshold, cooksThreshold);
                    listBox2.SelectedIndexChanged += new System.EventHandler(this.listBox2_SelectedIndexChanged);
                }
            }
        }


        private MultipleRegression computeModel(DataTable dt)
        {
            if (_dataMgr.ModelFieldList == null) return null;
            
            MultipleRegression model = null;
            string[] idvars = CreateResidualModelList().ToArray();
            string dvar = _dataMgr.ModelDependentVariable;

            if (dt != null)
            {
                model = new MultipleRegression(dt, dvar, idvars);
                try { model.Compute(); }
                catch { return null; }
            }

            return model;
        }


        private DataTable CreateResidualModelDataTable()
        {
            DataTable dtCorr = _dataMgr.ModelDataTable;
            DataView dvCorr = dtCorr.DefaultView;

            List<string> list = new List<string>();

            list.Add(dtCorr.Columns[0].ColumnName);
            list.Add(_dataMgr.ModelDependentVariable);

            foreach (KeyValuePair<string, double> kvp in _dataMgr.Model)
                if (kvp.Key != "(Intercept)") list.Add(kvp.Key);
                        
            DataTable dtModel = dvCorr.ToTable("ModelData", false, list.ToArray());

            return dtModel;
        }


        private List <string> CreateResidualModelList()
        {
            List<string> list = new List<string>();

            foreach (KeyValuePair<string, double> kvp in _dataMgr.Model)
                if (kvp.Key != "(Intercept)") list.Add(kvp.Key);

            return list;
        }


        private void setLabels(bool init, double dffitsThreshold, double cooksThreshold)
        {
            if (rbDFFITS.Checked)
            {
                lblIterativeThreshold.Text = "2*SQR(p/n) = " + dffitsThreshold.ToString("f4");
                lblAutoThreshold.Text = "Stop when all DFFITS values less than " + dffitsThreshold.ToString("f4");
                rbAutoIterativeThreshold.Text = "iterative threshold using 2*SQR(p/n) = " + dffitsThreshold.ToString("f4");
                if (init) tboxAutoConstantThresholdValue.Text = (0.9 * dffitsThreshold).ToString("f4");
            }
            else if (rbCooks.Checked)
            {
                lblIterativeThreshold.Text = "4.0/n = " + cooksThreshold.ToString("f4");
                lblAutoThreshold.Text = "Stop when all Cooks values less than " + cooksThreshold.ToString("f4");
                rbAutoIterativeThreshold.Text = "iterative threshold using 4.0/n = " + cooksThreshold.ToString("f4");
                if (init) tboxAutoConstantThresholdValue.Text = (0.9 * cooksThreshold).ToString("f4");
            }

            if (rbAutoIterativeThreshold.Checked)
            {
                _dffitsThreshold = dffitsThreshold;
                _cooksThreshold = cooksThreshold;
            }

            else if (rbAutoConstantThreshold.Checked)
            {
                _dffitsThreshold = Convert.ToDouble(tboxAutoConstantThresholdValue.Text);
                _cooksThreshold = Convert.ToDouble(tboxAutoConstantThresholdValue.Text);
            }
        }


        private DataTable getDFFITSTable(MultipleRegression model, DataTable dt, bool prepare)
        {
            //given a model, get dffits stat. passed dt is data used in model build
            _dffits = model.DFFITS;

            //build a sorted table/view for UI display
            DataTable dtDFFITS = getResidualsTable("DFFITS", _dffits, dt);
            DataView view = dtDFFITS.DefaultView;
            view.Sort = "DFFITS DESC";
            dgvResid.DataSource = view;

            //prepare for next rebuild
            if (prepare)
            {
                //if (!_dffitsRecs2Remove.Contains(_dffitsRecno2Remove))
                {
                    _dffitsRecno2Remove = Convert.ToInt32(dgvResid.Rows[0].Cells[0].Value.ToString());
                    _dffitsDateTime2Remove = dgvResid.Rows[0].Cells[1].Value.ToString();
                    _dffitsResidValue2Remove = Convert.ToDouble(dgvResid.Rows[0].Cells[2].Value.ToString());
                }
            }

            //update the dffits threshold (2*sqr(p/n)) where p = # of predictor variables and n = # of observations
            //(p=cols-2; 1 is timestamp, 2 is dependent variable)
            //double dffitsThreshold = Convert.ToDouble(
            //    (2.0d * Math.Sqrt(((double)dt.Columns.Count - 2) / (double)model.PredictedValues.Length)).ToString());

            //issue with cutoff - need variable count in model, not variable count in datatable
            int p = CreateResidualModelDataTable().Columns.Count - 2;
            double dffitsThreshold = Convert.ToDouble(
                (2.0d * Math.Sqrt(((double)p) / (double)model.PredictedValues.Length)).ToString());

            setLabels(false, dffitsThreshold, _cooksThreshold);

            //lblADStat.Text = lblADStat.Text.Substring(0, 13) + dffitsThreshold.ToString("f4");

            //if (rbConstantCutoff.Checked)
            //{
            //    //textBox3.Text = dffitsThreshold.ToString("f4");
            //    //label3.Text = label3.Text.Substring(0, 13) + dffitsThreshold.ToString("f4");
            //    //_dffitsThreshold = dffitsThreshold;
            //}
            //else if (rbIterativeCutoff.Checked)
            //{
            //    //textBox3.Text = dffitsThreshold.ToString("f4");
            //    _dffitsThreshold = dffitsThreshold;
            //}


            return dtDFFITS;
        }


        private DataTable getCooksDistanceTable(MultipleRegression model, DataTable dt, bool prepare)
        {
            _cooks = model.Cooks;

            DataTable dtCooks = getResidualsTable("CooksDist", _cooks, dt);
            DataView view = dtCooks.DefaultView;
            view.Sort = "CooksDist Desc";
            dgvResid.DataSource = view;
            
            if (prepare)
            {

                //if (!_cooksRecs2Remove.Contains(_cooksRecno2Remove))
                {
                    //save the record, value and type to remove
                    _cooksRecno2Remove = Convert.ToInt32(dgvResid.Rows[0].Cells[0].Value.ToString());
                    _cooksDataTime2Remove = dgvResid.Rows[0].Cells[1].Value.ToString();
                    _cooksResidValue2Remove = Convert.ToDouble(dgvResid.Rows[0].Cells[2].Value.ToString());
                }

            }

            //update the cooks threshold (4/n) 
            double cooksThreshold = 4.0d / (double)model.PredictedValues.Length;

            setLabels(false, _dffitsThreshold, cooksThreshold);

            //label10.Text = label10.Text.Substring(0, 10) + cooksThreshold.ToString("f4");

            //if (rbCookConstantCutoff.Checked)
            //{
            //    //tbcookcutoff.Text = cooksThreshold.ToString("f4");
            //}
            //else if (rbCooksIterativeCutoff.Checked)
            //{
            //    //label10.Text = label10.Text.Substring(0, 10) + _cooksThreshold.ToString("f4");
            //    _cooksThreshold = cooksThreshold;
            //}


            return dtCooks;
        }


        private DataTable getResidualsTable(string residName, double[] residuals, DataTable dtModel)
        {
            DataTable dt = new DataTable();
            dt.Columns.Add("Record", typeof(System.Int32));
            dt.Columns.Add("Date/Time", typeof(System.String));
            dt.Columns.Add(residName, typeof(System.String));
            object[] values = new object[3];

            for (int rec = 0; rec < dtModel.Rows.Count; rec++)
            {
                int recno = rec;
                values[0] = Convert.ToInt32(string.Format("{0:N0}", recno.ToString()));
                values[1] = dtModel.Rows[rec][0].ToString();
                values[2] = residuals[rec].ToString("F6");
                dt.Rows.Add(values);
            }

            return dt;
        }


        private void btnGoDFFITSRebuild_Click(object sender, EventArgs e)
        {
            //iterative rebuild button clicked, get the current model table name
            //copy the table, remove the record with the largest dffits stat, rebuild the model
            //get the dffits stats and table, update the model list and recreate the plots

            DataTable dt = _modelBuildTables.Tables[_currentModelTableName];
            DataTable opdt = dt.Copy();

            if (opdt.Rows.Count <= 10)
            {
                MessageBox.Show("Data insufficient for further record removal.", "Maximum Number of Records Removed", MessageBoxButtons.OK);
                _continue = false;
                return; 
            }

            opdt.Rows[_dffitsRecno2Remove].Delete();
            opdt.AcceptChanges();

            //track removed records here...
            _recsRemoved.Add(getRecordRemoved(_dffitsDateTime2Remove));
            _residValueRemoved.Add(_dffitsResidValue2Remove);
            _residTypeRemoved.Add("DFFITS");

            _model = computeModel(opdt);

            string[] tags = (from DataRow dr in _model.Data.Rows select dr[0].ToString()).Cast<string>().ToArray();
            DataTable dffits = getDFFITSTable(_model, opdt, true);
            DataTable cooks = getCooksDistanceTable(_model, opdt, true);

            //**********************
            _listRebuilds.Add(_model);
            //**********************
            
            string modelname = UpdateModelList(_model, "next", opdt, "df");
            UpdateListViews(_model, modelname);
            createResidPlot("DFFITS", dffits, tags);
            createResidPlot("CooksDistance", cooks, tags);
            createResidvFittedPlot(_model, tags);
            _continue = true;

        }

        private void btnGoCooksIterative_Click(object sender, EventArgs e)
        {
            DataTable dt = _modelBuildTables.Tables[_currentModelTableName];
            DataTable opdt = dt.Copy();

            if (opdt.Rows.Count <= 10)
            {
                MessageBox.Show("Data insufficient for further record removal.", "Maximum Number of Records Removed", MessageBoxButtons.OK);
                _continue = false;
                return; // false;
            }
            opdt.Rows[_cooksRecno2Remove].Delete();
            opdt.AcceptChanges();

            //track removed records here...
            _recsRemoved.Add(getRecordRemoved(_cooksDataTime2Remove));
            _residValueRemoved.Add(_cooksResidValue2Remove);
            _residTypeRemoved.Add("COOKS");

            _model = computeModel(opdt);

            string[] tags = (from DataRow dr in _model.Data.Rows select dr[0].ToString()).Cast<string>().ToArray();
            DataTable dffits = getDFFITSTable(_model, opdt, true);
            DataTable cooks = getCooksDistanceTable(_model, opdt, true);

            //**********************
            _listRebuilds.Add(_model);
            //**********************

            string modelname = UpdateModelList(_model, "next", opdt, "cd");
            UpdateListViews(_model, modelname);
            createResidPlot("DFFITS", dffits, tags);
            createResidPlot("CooksDistance", cooks, tags);
            createResidvFittedPlot(_model, tags);
            _continue = true;
        }


        private int getRecordRemoved(string datetimestamp)
        {
            //wouldn't have to do this if grids weren't sorted (and with records recursively removed)
            int ndx = -1;
            foreach (DataRow r in _modelBuildTables.Tables[0].Rows)
            {
                ndx++;
                if (r[0].ToString() != datetimestamp) continue;
                //otherwise we found it
                return ndx;
            }
            return -1;
        }


        private void btnGoDFFITSAuto_Click(object sender, EventArgs e)
        {
            //auto rebuild until dffits < cutoff 
            //this will need some exit criteria before we run out of data
            //and/or mlr models cannot be built due to lack of data

            double maxDFFITS = Math.Abs(Convert.ToDouble(dgvResid[2, 0].Value.ToString()));

            while (maxDFFITS >= _dffitsThreshold)
            {
                if (_continue)
                    btnGoDFFITSRebuild_Click(null, new EventArgs());
                else
                    break;

                maxDFFITS = Math.Abs(Convert.ToDouble(dgvResid[2, 0].Value.ToString()));

                DataTable dt = _modelBuildTables.Tables[_currentModelTableName];
                if (dt.Rows.Count < _maxIterations) break;
            }
        }

        private void btnGoCooksAuto_Click(object sender, EventArgs e)
        {
            //auto rebuild until cooks < cutoff 
            //this will need some exit criteria before we run out of data
            //and/or mlr models cannot be build due to lack of data

            double maxCOOKS = Math.Abs(Convert.ToDouble(dgvResid[2, 0].Value.ToString()));

            while (maxCOOKS >= _cooksThreshold)
            {
                if (_continue)
                    btnGoCooksIterative_Click(null, new EventArgs());
                else
                    break;

                maxCOOKS = Math.Abs(Convert.ToDouble(dgvResid[2, 0].Value.ToString()));

                DataTable dt = _modelBuildTables.Tables[_currentModelTableName];
                if (dt.Rows.Count < _maxIterations) break;
            }
        }


        private string UpdateModelList(MultipleRegression model, string name, DataTable dt, string residType)
        {
            //track models by their build tables and name
            //create a table name
            string listitem = string.Empty;
            int n = _modelBuildTables.Tables.Count;

            if (!_residualInfo.ContainsKey(n))
            {
                if (name == "original")
                {
                    listitem = "SelectedModel";
                }
                else
                {
                    listitem = "Rebuild" + n;
                }

                //track rebuild info
                _residualInfo.Add(n, residType);

                //copy the model table and save it
                DataTable newDT = new DataTable();
                newDT = dt.Copy();
                newDT.TableName = listitem.ToString();
                if (!_modelBuildTables.Tables.Contains(listitem.ToString()))
                    _modelBuildTables.Tables.Add(newDT);

                //add the model (name) to the UI list
                listBox2.Items.Add(listitem);
                listBox2.SelectedItem = listitem;                                
            }
            return listitem;
        }


        private void UpdateListViews(MultipleRegression model, string tabname)
        {
            tabStats.TabPages["tabVariableStats"].Text =  "Variable Statistics - " + tabname;
            tabStats.TabPages["tabModelStats"].Text = "Model Statistics - " + tabname;

            //given a mlr model, update the UI lists with its stats
            listView1.Items.Clear();
            listView2.Items.Clear();

            string[] item = null;
            ListViewItem lvi = null;

            //show variable statistics and save the name for use elsewhere - always rebuild from last performed, not what is selected in UI listbox
            _currentModelTableName = tabname;
            int numColumns = model.Parameters.Columns.Count;
            for (int i = 0; i < model.Parameters.Rows.Count; i++)
            {
                item = new string[numColumns];
                item[0] = model.Parameters.Rows[i][0].ToString();
                item[1] = formatNumber((double)model.Parameters.Rows[i][1]);
                item[2] = formatNumber((double)model.Parameters.Rows[i][2]);
                item[3] = formatNumber((double)model.Parameters.Rows[i][3]);
                item[4] = formatNumber((double)model.Parameters.Rows[i][4]);
                item[5] = formatNumber((double)model.Parameters.Rows[i][5]);
                lvi = new ListViewItem(item);
                listView1.Items.Add(lvi);
            }

            //show model statistics
            item = new string[2];
            item[0] = "R Squared";
            item[1] = String.Format("{0:F4}", model.R2);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "Adjusted R Squared";
            item[1] = String.Format("{0:F4}", model.AdjustedR2);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "Akaike Information Criterion";
            item[1] = String.Format("{0:F4}", model.AIC);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "Corrected AIC";
            item[1] = String.Format("{0:F4}", model.AICC);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "Bayesian Info Criterion";
            item[1] = String.Format("{0:F4}", model.BIC);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "PRESS";
            item[1] = String.Format("{0:F4}", model.Press);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "RMSE";
            item[1] = String.Format("{0:F4}", model.RMSE);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            ModelErrorCounts mec = new ModelErrorCounts();
            mec.getCounts(mlrPlots1.ThresholdHoriz, mlrPlots1.ThresholdVert, model.PredictedValues, model.ObservedValues);

            item = new string[2];
            item[0] = "";
            item[1] = "";
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "Transformed DC";
            item[1] = string.Format("{0:F4}", mlrPlots1.ThresholdHoriz);

            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "Transformed RS";
            item[1] = string.Format("{0:F4}", mlrPlots1.ThresholdVert);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "False Positives";
            item[1] = string.Format("{0:n}", mec.FPCount);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "Specificity";
            item[1] = String.Format("{0:F4}", mec.Specificity);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "False Negatives";
            item[1] = string.Format("{0:n}", mec.FNCount);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "Sensitivity";
            item[1] = String.Format("{0:F4}", mec.Sensitivity);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "Accuracy";
            item[1] = String.Format("{0:F4}", mec.Accuracy);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            item = new string[2];
            item[0] = "";
            item[1] = "";
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);

            int numRecords = model.PredictedValues.Length;
            item = new string[2];
            item[0] = "Number of Observations";
            item[1] = string.Format("{0}", numRecords);
            lvi = new ListViewItem(item);
            listView2.Items.Add(lvi);
        }


        private string formatNumber(double number)
        {
            string fmtstring = string.Empty;
            if (number.Equals(double.NaN)) return fmtstring;
            if (Math.Abs(number) >= 10000 || Math.Abs(number) <= 0.0001)
                fmtstring = "{0:0.000#e-00}";
            else fmtstring = "{0:f4}";
            return string.Format(fmtstring, number);
        }


        private void createResidPlot(string plotname, DataTable residuals, string[] tags=null)
        {
            ZedGraphControl zgcCtrl = null;

            ////switch to correct plot control
            //if (plotname.Contains("DFFITS")) zgcCtrl = zgcDFFITS;
            //else if (plotname.Contains("Cooks")) zgcCtrl = zgcCooks;
            //else return;
            zgcCtrl = zgcResidualsPlot;

            GraphPane pane = zgcCtrl.GraphPane;
            pane.Title.Text = "Residuals";
            if (pane.CurveList.Count > 0) pane.CurveList.Clear();
            PointPairList pts = getPPList(residuals, false, tags);
            LineItem curve = pane.AddCurve(plotname, pts, Color.Blue, SymbolType.Default);
            pane.XAxis.Title.Text = "Record";
            pane.YAxis.Title.Text = plotname;
            curve.Line.IsVisible = false;

            //if (zgcCtrl.Equals(zgcDFFITS))
            if (plotname == "DFFITS")
            {
                //add threshold traces
                PointPairList dthreshold1 = new PointPairList();
                dthreshold1.Add(0.0d, _dffitsThreshold);
                dthreshold1.Add(Convert.ToDouble(residuals.Rows.Count.ToString()), _dffitsThreshold);

                PointPairList dthreshold2 = new PointPairList();
                dthreshold2.Add(0.0d, -_dffitsThreshold);
                dthreshold2.Add(Convert.ToDouble(residuals.Rows.Count.ToString()), -_dffitsThreshold);

                LineItem dcurve1 = pane.AddCurve("cutoff = " + _dffitsThreshold.ToString("f4"), dthreshold1, Color.Red, SymbolType.None);
                dcurve1.Line.IsVisible = true;
                LineItem dcurve2 = pane.AddCurve("-cutoff  = -" + _dffitsThreshold.ToString("f4"), dthreshold2, Color.Red, SymbolType.None);
                dcurve2.Line.IsVisible = true;
            }
            //else if (zgcCtrl.Equals(zgcCooks))
            else if (plotname == "CooksDistance")
            {
                //add threshold trace
                PointPairList cthreshold = new PointPairList();
                cthreshold.Add(0.0d, _cooksThreshold);
                cthreshold.Add(Convert.ToDouble(residuals.Rows.Count.ToString()), _cooksThreshold);

                LineItem dcurve1 = pane.AddCurve("cutoff = " + _cooksThreshold.ToString("f4"), cthreshold, Color.Red, SymbolType.None);
                dcurve1.Line.IsVisible = true;
            }

            zgcCtrl.IsShowPointValues = true;
            zgcCtrl.AxisChange();
            zgcCtrl.Refresh();
        }


        /// <summary>
        /// create the residuals vs fitted plot and the fitted vs obs plot (via mlrplotcontrol)
        /// </summary>
        /// <param name="model"></param>
        private void createResidvFittedPlot(MultipleRegression model, string[] tags)
        {
            MasterPane master = zgcResidvFitted.MasterPane;
            master.PaneList.Clear();

            master.Title.IsVisible = false;
            master.Margin.All = 10;

            //create the predictions vs studentized residuals plot;
            _predictions = model.PredictedValues;
            _standardResiduals = model.StudentizedResiduals;
            _observations = model.ObservedValues;

            //get different values of adstat with direct call (above)
            //...from this below which uses the adtestofnormality directly in the linearmodel object... (see statistics.multipleregression.compute)
            //won't match numbers passing residuals or standardized residuals to the test above - revisit this when possible
            double adstat1 = model.ADResidNormStatVal;
            double adstat1pval = model.ADResidPvalue;

            lblADStat.Text = "A.D. Normality Statistic = " + adstat1.ToString("f4");
            lblADPVal.Text = "A.D. Statistic P-value = " + adstat1pval.ToString("f4");

            GraphPane gpResidPlot = addPlotResid(_predictions, _standardResiduals, tags);
            List<double[]> data = new List<double[]>();
            double[] record = null;
            for (int i = 0; i < _predictions.Length; i++)
            {
                record = new double[2];
                record[0] = _observations[i];
                record[1] = _predictions[i];
                data.Add(record);
            }

            double dec, man;

            ModelRebuildFitExceedances();
            //mlrPlots2.UpdateResults(data, model.RMSE, MLRPlots.Exceedance.model, tags);
            mlrPlots2.UpdateResults(data, model.RMSE, mlrPlots2._exceedance, tags);
            mlrPlots2.btnXYPlot_Click(null, null);

            master.Add(gpResidPlot);
            rbTable_CheckedChanged(null, null);

            using (Graphics g = this.CreateGraphics())
            { master.SetLayout(g, PaneLayout.SquareColPreferred); }

            zgcResidvFitted.IsShowPointValues = true;
            zgcResidvFitted.AxisChange();
            master.AxisChange();
            zgcResidvFitted.Refresh();
        }


        private GraphPane addPlotResid(double[] _predictions, double[] _standardResiduals, string[] tags)
        {
            GraphPane pane = new GraphPane();

            pane.Title.Text = "Studentized Residuals vs Fitted";
            if (pane.CurveList.Count > 0) pane.CurveList.Clear();

            PointPairList ppl = new PointPairList();
            for (int i = 0; i < _predictions.Length; i++)
            {
                ppl.Add(x:_predictions[i], y:_standardResiduals[i], tag:tags[i]);
            }

            //LineItem curve = pane.AddCurve(null, _predictions, _standardResiduals, Color.Blue, SymbolType.Circle);
            LineItem curve = pane.AddCurve(null, ppl, Color.Blue, SymbolType.Circle);

            pane.XAxis.Title.Text = "Fitted";
            pane.YAxis.Title.Text = "Studentized Residuals";
            curve.Line.IsVisible = false;
            zgcResidvFitted.AxisChange();
            zgcResidvFitted.Refresh();

            return pane;
        }


        private PointPairList getPPList(DataTable dt, bool xdate, string[] tags)
        {
            //create a point list for the dffits plot

            double x;
            double y;
            string tag = string.Empty;
            PointPairList plist = new PointPairList();
            for (int i=0; i<dt.Rows.Count; i++)
            {
                DataRow r = dt.Rows[i];
                if (xdate)
                {
                    DateTime date = Convert.ToDateTime(r[0].ToString());
                    tag = date.ToShortDateString();
                    x = new ZedGraph.XDate(date);
                    y = Convert.ToDouble(r[1].ToString());
                    tag += " (" + y.ToString() + ")";
                    plist.Add(x, y, tag);
                }
                else
                {
                    tag = tags[i]; //r[0].ToString();
                    x = Convert.ToDouble(r[0].ToString());
                    y = Convert.ToDouble(r[2].ToString());
                    plist.Add(x, y, tag);
                }
            }
            return plist;
        }


        private void listBox2_SelectedIndexChanged(object sender, EventArgs e)
        {
            //user selected a model in list, get its data table, build its model, 
            //update the model stats lists and create the plots for the model
            if (listBox2.SelectedIndex < 0) return;

            _selectedRebuild = listBox2.SelectedIndex;

            string modelname = listBox2.SelectedItem.ToString();
            DataTable dt = _modelBuildTables.Tables[modelname];
            if (dt != null)
            {
                MultipleRegression model = computeModel(dt);
                _dataMgr.ResidualAnalysisInfo.SelectedModelRMSE = model.RMSE;
                _dataMgr.Model = model.Model;
                UpdateListViews(model, modelname);
                string[] tags = (from DataRow dr in model.Data.Rows select dr[0].ToString()).Cast<string>().ToArray();

                if (rbDFFITS.Checked)
                {
                    showResid("DFFITS");
                }
                else if (rbCooks.Checked)
                {
                    showResid("Cooks");
                }

                createResidvFittedPlot(model, tags);

                _selectedRebuildIndex = _selectedRebuild;
                dictPackedState = ProjectSave();
                if (ModelChanged != null) { ModelChanged(); }
            }
        }


        private void tboxAutoConstantThresholdValue_Validated(object sender, EventArgs e)
        {
            errorProvider1.SetError(tboxAutoConstantThresholdValue, "");
        }


        private void tboxAutoConstantThresholdValue_Validating(object sender, CancelEventArgs e)
        {
            //validate the user input for cutoff value
            //will probably need some smarter critera for minimum value permitted...

            double newcutoff = double.NaN;
            string teststring = tboxAutoConstantThresholdValue.Text;
            if (!double.TryParse(teststring, out newcutoff))
            {
                e.Cancel = true;
                tboxAutoConstantThresholdValue.Select(0, tboxAutoConstantThresholdValue.Text.Length);
                this.errorProvider1.SetError(tboxAutoConstantThresholdValue, "Text must convert to a number.");
                //MessageBox.Show("Must convert to number", "Invalid entry", MessageBoxButtons.OK);
                return;
            }
            else if (newcutoff >= 3.0d)
            {
                e.Cancel = true;
                tboxAutoConstantThresholdValue.Select(0, tboxAutoConstantThresholdValue.Text.Length);
                this.errorProvider1.SetError(tboxAutoConstantThresholdValue, "Value must be less than 3");
                //MessageBox.Show("Value must be less than 3", "Invalid entry", MessageBoxButtons.OK);
                return;
            }
            else
            {
                _dffitsThreshold = newcutoff;
            }
        }

        
        /// <summary>
        /// starts the residual process all over
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnClear_Click(object sender, EventArgs e)
        {
            DataTable modeldt = _dataMgr.ModelDataTable;

            MultipleRegression model = computeModel(modeldt);

            _gobtnState = true;

            //cutoff rebuilds when half data records eliminated
            _maxIterations = modeldt.Rows.Count / 2;

            _recsRemoved = new List<int>();
            _residValueRemoved = new List<double>();
            _residTypeRemoved = new List<string>();

            listBox2.Items.Clear();
            _modelBuildTables.Tables.Clear();
            _residualInfo = new Dictionary<int, string>();

            DataTable dffits = getDFFITSTable(model, modeldt, true);
            DataTable cooks = getCooksDistanceTable(model, modeldt, true);
            string[] tags = (from DataRow dr in model.Data.Rows select dr[0].ToString()).Cast<string>().ToArray();

            string modelname = UpdateModelList(model, "original", modeldt, "model");
            UpdateListViews(model, modelname);

            //create rediduals plots
            createResidPlot("DFFITS", dffits, tags);
            createResidPlot("CooksDistance", cooks, tags);

            //predictions vs standardized residuals plot
            createResidvFittedPlot(model, tags);

            //resets the model in prediction if they've selected one of the rebuilds they've just cleared
            listBox2.SelectedIndex = 0;
            _continue = true;
        }


        private void btnGoIterative_Click(object sender, EventArgs e)
        {
            if (rbDFFITS.Checked)
            {
                btnGoDFFITSRebuild_Click(btnGoIterative, null);
            }
            else if (rbCooks.Checked)
            {
                btnGoCooksIterative_Click(btnGoIterative, null);
            }
        }


        private void btnGoAuto_Click(object sender, EventArgs e)
        {
            if (rbDFFITS.Checked)
            {
                //btnGoDFFITSRebuild_Click(btnGoIterative, null);
                btnGoDFFITSAuto_Click(btnGoAuto, null);
            }
            else if (rbCooks.Checked)
            {
                //btnGoCooksIterative_Click(btnGoIterative, null);
                btnGoCooksAuto_Click(btnGoAuto, null);
            }
        }


        private void rbTable_CheckedChanged(object sender, EventArgs e)
        {
            if (rbTable.Checked)
            {
                if (rbDFFITS.Checked)
                {
                    showResid("DFFITS");
                }
                else if (rbCooks.Checked)
                {
                    showResid("Cooks");
                }
            }
        }


        private void rbPlot_CheckedChanged(object sender, EventArgs e)
        {
            if (rbPlot.Checked)
            {
                if (rbDFFITS.Checked)
                {
                    showResid("DFFITS");
                }
                else if (rbCooks.Checked)
                {
                    showResid("Cooks");
                }
            }
        }


        private void rbDFFITS_CheckedChanged(object sender, EventArgs e)
        {
            if (rbDFFITS.Checked)
            {
                showResid("DFFITS");
            }
        }


        private void rbCooks_CheckedChanged(object sender, EventArgs e)
        {
            if (rbCooks.Checked)
            {
                showResid("Cooks");
            }
        }


        private void showResid(string residType)
        {
            if (listBox2.Items.Count <= 0) return;

            string modelname = listBox2.SelectedItem.ToString();
            DataTable modeldt = _modelBuildTables.Tables[modelname];
            MultipleRegression model = computeModel(modeldt);
            string[] tags = (from DataRow dr in model.Data.Rows select dr[0].ToString()).Cast<string>().ToArray();

            if (rbTable.Checked)
            {
                if (residType == "DFFITS")
                {
                    DataTable dummy = getDFFITSTable(model, modeldt, false);
                }
                else if (residType == "Cooks")
                {
                    DataTable dummy = getCooksDistanceTable(model, modeldt, false);
                }
                zgcResidualsPlot.Visible = false;
            }
            else if (rbPlot.Checked)
            {
                if (residType == "DFFITS")
                {
                    DataTable residuals = getDFFITSTable(model, modeldt, false);
                    createResidPlot("DFFITS", residuals, tags);
                }
                else if (residType == "Cooks")
                {
                    DataTable residuals = getCooksDistanceTable(model, modeldt, false);
                    createResidPlot("CooksDistance", residuals, tags);
                }
                zgcResidualsPlot.Visible = true;
            }
        }


        private void tabControl3_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (tabControl3.SelectedTab.Name == "tabDFFITSCooks")
            {
                gboxCtrls.Visible = true;
            }
            else
            {
                gboxCtrls.Visible = false;
            }
        }


        private void btnViewDataTable_Click(object sender, EventArgs e)
        {
            frmDataTable frmDT = new frmDataTable(_recsRemoved, _residValueRemoved,
             _residTypeRemoved, _modelBuildTables.Tables[0]);
            frmDT.Show();
        }
        #endregion
        

        public event EventHandler VariablesChanged;

        /// <summary>
        /// Set the data for variable selection
        /// </summary>
        /// <param name="dt"></param>
        public void EstablishValidVariables(DataTable dt)
        {
            if (dt == null || dt.Columns.Count < 2)
                return;

            lbAvailableVariables.Items.Clear();
            lbIndVariables.Items.Clear();
            _lstSelectedVariables = new List<string>();

            List<string> fieldList = new List<string>();
            for (int i = 1; i < dt.Columns.Count; i++)
            {
                bool bDependentVariableColumn = false;

                if (dt.Columns[i].ExtendedProperties.ContainsKey(VBCommon.Globals.DEPENDENTVAR))
                {
                    if (dt.Columns[i].ExtendedProperties[VBCommon.Globals.DEPENDENTVAR].ToString() == "True")
                    {
                        bDependentVariableColumn = true;
                        lblDepVarName.Text = dt.Columns[i].ColumnName;
                    }
                }

                if (!bDependentVariableColumn && dt.Columns[i].ExtendedProperties.ContainsKey(VBCommon.Globals.ENABLED))
                {
                    if (dt.Columns[i].ExtendedProperties[VBCommon.Globals.ENABLED].ToString() == "True")
                        fieldList.Add(dt.Columns[i].ColumnName);
                }
                else if (!bDependentVariableColumn)
                    fieldList.Add(dt.Columns[i].ColumnName);
            }

            for (int i=0;i<fieldList.Count;i++)
                lbAvailableVariables.Items.Add(new ListItem(fieldList[i], i.ToString()));        
        }


        public void SetSelectedVariables(List<string> Selected)
        {
            ClearAllVariables();
            AddToList(Selected);
        }


        public void ClearAllVariables()
        {
            List<ListItem> items = new List<ListItem>();
            _lstSelectedVariables = new List<string>();

            for (int i = 0; i < lbIndVariables.Items.Count; i++)
            {
                ListItem li = (ListItem)lbIndVariables.Items[i];
                items.Add(li);
            }

            foreach (ListItem li in items)
            {
                lbIndVariables.Items.Remove(li);

                bool foundIdx = false;
                int j = 0;
                for (j = 0; j < lbAvailableVariables.Items.Count; j++)
                {
                    ListItem li2 = (ListItem)lbAvailableVariables.Items[j];
                    if (Convert.ToInt32(li2.ValueItem) > Convert.ToInt32(li.ValueItem))
                    {
                        lbAvailableVariables.Items.Insert(j, li);
                        foundIdx = true;
                        break;
                    }
                }
                if (foundIdx == false)
                    lbAvailableVariables.Items.Insert(j, li);
            }
            
            lblNumAvailVars.Text = "(" + lbAvailableVariables.Items.Count.ToString() + ")";
            lblNumIndVars.Text = "(" + lbIndVariables.Items.Count.ToString() + ")";

            SelectedVariablesChanged();
        }


        public void AddToList(List<string> varlist)
        {
            List<ListItem> items = new List<ListItem>();

            for (int i = 0; i < lbAvailableVariables.Items.Count; i++)
            {
                ListItem li = (ListItem)lbAvailableVariables.Items[i];
                if (varlist.Contains<string>(li.DisplayItem))
                {
                    items.Add(li);
                }
            }

            foreach (ListItem li in items)
            {
                lbAvailableVariables.Items.Remove(li);
                lbIndVariables.Items.Add(li);
                _lstSelectedVariables.Add(li.DisplayItem);
            }

            lblNumAvailVars.Text = "(" + lbAvailableVariables.Items.Count.ToString() + ")";
            lblNumIndVars.Text = "(" + lbIndVariables.Items.Count.ToString() + ")";

            SelectedVariablesChanged();
        }


        private void btnAddInputVariable_Click(object sender, EventArgs e)
        {
            List<ListItem> items = new List<ListItem>();

            int selectedIndices = lbAvailableVariables.SelectedIndices.Count;
            for (int i = 0; i < selectedIndices; i++)
            {
                ListItem li = (ListItem)lbAvailableVariables.Items[lbAvailableVariables.SelectedIndices[i]];
                items.Add(li);
            }

            foreach (ListItem li in items)
            {
                lbAvailableVariables.Items.Remove(li);
                lbIndVariables.Items.Add(li);
                _lstSelectedVariables.Add(li.DisplayItem);
            }

            lblNumAvailVars.Text = "(" + lbAvailableVariables.Items.Count.ToString() + ")";
            lblNumIndVars.Text = "(" + lbIndVariables.Items.Count.ToString() + ")";

            SelectedVariablesChanged();
        }


        private void btnRemoveInputVariable_Click(object sender, EventArgs e)
        {
            List<ListItem> items = new List<ListItem>();

            for (int i = 0; i < lbIndVariables.SelectedIndices.Count; i++)
            {
                ListItem li = (ListItem)lbIndVariables.Items[lbIndVariables.SelectedIndices[i]];
                items.Add(li);
            }

            foreach (ListItem li in items)
            {
                lbIndVariables.Items.Remove(li);
                if (_lstSelectedVariables.Contains(li.DisplayItem)) { _lstSelectedVariables.Remove(li.DisplayItem); }

                bool foundIdx = false;
                int j = 0;
                for (j = 0; j < lbAvailableVariables.Items.Count; j++)
                {
                    ListItem li2 = (ListItem)lbAvailableVariables.Items[j];
                    if (Convert.ToInt32(li2.ValueItem) > Convert.ToInt32(li.ValueItem))
                    {
                        lbAvailableVariables.Items.Insert(j, li);
                        foundIdx = true;
                        break;
                    }
                }
                if (foundIdx == false)
                    lbAvailableVariables.Items.Insert(j, li);
            }
            
            lblNumAvailVars.Text = "(" + lbAvailableVariables.Items.Count.ToString() + ")";
            lblNumIndVars.Text = "(" + lbIndVariables.Items.Count.ToString() + ")";

            SelectedVariablesChanged();
        }


        public List<string> SelectedVariables
        {
            get 
            {
                List<string> list = new List<string>();
                for (int i = 0; i < lbIndVariables.Items.Count; i++)
                {
                    ListItem li = lbIndVariables.Items[i] as ListItem;
                    list.Add(li.DisplayItem);
                }
                return list;
            }
            set
            {
                _lstSelectedVariables = value;
                SetSelectedVariables(_lstSelectedVariables);
                //only invoke if the list has been populated
                if (_lstSelectedVariables != null)
                    SelectedVariablesChanged();
            }
        }


        private void groupBox1_Resize(object sender, EventArgs e)
        {
            Control control = (Control)sender;

            int width = control.Width;

            if (width <= control.MinimumSize.Width)
                return;

            lbAvailableVariables.Width = (width - 100) / 2;

            int xLoc = lbAvailableVariables.Location.X + lbAvailableVariables.Width + 50;
            lbIndVariables.Location = new Point(xLoc, lbAvailableVariables.Location.Y);
            lbIndVariables.Width = (width - 100) / 2;

            xLoc = lbAvailableVariables.Location.X + lbAvailableVariables.Width + 10;
            btnAddInputVariable.Location = new Point(xLoc, btnAddInputVariable.Location.Y);
            btnRemoveInputVariable.Location = new Point(xLoc, btnRemoveInputVariable.Location.Y);
        }


        public Dictionary<string, List<ListItem>> PackVariableSelectionState()
        {
            Dictionary<string, List<ListItem>> dctState = new Dictionary<string, List<ListItem>>();
            List<ListItem> listAvail = new List<ListItem>();
            List<ListItem> listInd = new List<ListItem>(); ;

            for (int i = 0; i < lbAvailableVariables.Items.Count; i++)
                listAvail.Add(lbAvailableVariables.Items[i] as ListItem);

            for (int i = 0; i < lbIndVariables.Items.Count; i++)
                listInd.Add(lbIndVariables.Items[i] as ListItem);

            dctState.Add("AvailableVariables", listAvail);
            dctState.Add("IndependentVariables", listInd);

            return dctState;
        }


        public void UnpackVariableSelectionState(Dictionary<string, List<ListItem>> state)
        {
            List<ListItem> list = null;
            if (state.Keys.Contains("AvailableVariables"))
            {
                lbAvailableVariables.Items.Clear();
                list = state["AvailableVariables"];
                for (int i = 0; i < list.Count; i++)
                    lbAvailableVariables.Items.Add(list[i]);
            }

            list = null;

            if (state.Keys.Contains("IndependentVariables"))
            {
                lbIndVariables.Items.Clear();
                _lstSelectedVariables.Clear();
                list = state["IndependentVariables"];
                for (int i = 0; i < list.Count; i++)
                {
                    lbIndVariables.Items.Add(list[i]);
                    _lstSelectedVariables.Add(list[i].DisplayItem);
                }
            }

            lblNumAvailVars.Text = "(" + lbAvailableVariables.Items.Count.ToString() + ")";
            lblNumIndVars.Text = "(" + lbIndVariables.Items.Count.ToString() + ")";
        }


        private void txtMaxVars_TextChanged(object sender, EventArgs e)
        {
            int maxvars;

            if (Int32.TryParse(txtMaxVars.Text, out maxvars))
            {
                lblCombinationCount.Text = "There are " + Combinations(Available: _lstSelectedVariables.Count, MaxSelect: Convert.ToInt32(txtMaxVars.Text)) + " possible variable combinations";
            }
            else
            {
                lblCombinationCount.Text = "Maximum variables is not a valid entry.";
            }
        }


        private void UpdateExceedanceProbs(object sender, EventArgs args)
        {
            if (sender.Equals(mlrPlots1))
                ModelFitExceedances(Threshold: mlrPlots1.ThresholdHoriz);
            else if (sender.Equals(mlrPlots2))
                ModelRebuildFitExceedances(Threshold: mlrPlots2.ThresholdHoriz);
        }


    }
}
